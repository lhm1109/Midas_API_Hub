import { ScrollArea } from '@/components/ui/scroll-area';
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from '@/components/ui/resizable';
import { useState, useEffect, useMemo } from 'react';
import { ChevronRight, ChevronDown, Send, Save } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { CodeEditor } from '@/components/common';
import { apiSpecs } from '@/data/apiSpecs';
import { useAppStore } from '@/store/useAppStore';
import { apiClient } from '@/lib/api-client';
import type { ManualData } from '@/types';
import { 
  resolveActiveSchema, 
  isEnhancedSchemaActive, 
  compileSchema,
  canonicalToTableSchema,
  type UITableRow
} from '@/lib/schema';

interface SpecTabProps {
  endpoint: {
    id: string;
    name: string;
    method: string;
    path: string;
  };
}

export function SpecTab({ endpoint }: SpecTabProps) {
  const { 
    setManualData, 
    manualData, 
    currentVersionId, 
    getCurrentVersion, 
    updateSpecData,
    fetchVersions,
    loadVersion,
    specData,
  } = useAppStore();
  
  // ğŸ”¥ NEW: Schema Registryë¡œ í™œì„± ìŠ¤í‚¤ë§ˆ ê²°ì • (ìš°ì„ ìˆœìœ„ ì •ì±… ë¶„ë¦¬)
  const fallbackSpec = apiSpecs[endpoint.id] || {
    title: endpoint.name,
    description: 'API endpoint specification',
    parameters: [],
    jsonSchema: {},
  };
  
  // specDataì™€ fallbackì„ ê²°í•©
  const combinedSpecData = {
    jsonSchema: specData?.jsonSchema || fallbackSpec.jsonSchema,
    jsonSchemaOriginal: specData?.jsonSchemaOriginal || fallbackSpec.jsonSchema,
    jsonSchemaEnhanced: specData?.jsonSchemaEnhanced || fallbackSpec.jsonSchemaEnhanced,
    savedSchema: specData?.savedSchema,
  };
  
  // ğŸ¯ í™œì„± ìŠ¤í‚¤ë§ˆ (ìš°ì„ ìˆœìœ„: savedSchema > enhanced > original)
  const activeSchema = resolveActiveSchema(combinedSpecData);
  const hasEnhancedSchema = isEnhancedSchemaActive(combinedSpecData);
  
  // ğŸ”¥ NEW: Schema Compilerë¡œ ì •ê·œí™”ëœ AST ìƒì„±
  const canonicalFields = useMemo(() => {
    return compileSchema(activeSchema);
  }, [activeSchema]);
  
  // ğŸ”¥ NEW: UI Schema Adapterë¡œ í…Œì´ë¸” ìŠ¤í‚¤ë§ˆ ìƒì„±
  const tableParameters = useMemo(() => {
    return canonicalToTableSchema(canonicalFields);
  }, [canonicalFields]);
  
  const spec = {
    title: fallbackSpec.title,
    description: fallbackSpec.description,
    jsonSchema: combinedSpecData.jsonSchemaOriginal || {},
    jsonSchemaEnhanced: combinedSpecData.jsonSchemaEnhanced,
    uri: fallbackSpec?.uri,
    methods: fallbackSpec?.methods,
  };

  // Track which parameters are expanded
  const [expandedParams, setExpandedParams] = useState<Set<number>>(new Set());
  
  // ğŸ¯ Schema View Toggle: 'original' | 'enhanced'
  const [schemaView, setSchemaView] = useState<'original' | 'enhanced'>(() => {
    return hasEnhancedSchema ? 'enhanced' : 'original';
  });
  
  // ğŸ¯ Editable Schema State
  const [editableSchema, setEditableSchema] = useState<string>('');
  const [isSchemaModified, setIsSchemaModified] = useState(false);
  
  // ğŸ¯ ì €ì¥ëœ ìŠ¤í‚¤ë§ˆë¥¼ ì¶”ì í•˜ëŠ” state (ë¦¬ë Œë”ë§ íŠ¸ë¦¬ê±°ìš©)
  const [savedSchema, setSavedSchema] = useState<any>(null);
  
  // ğŸ”¥ endpoint ë³€ê²½ ì‹œ schemaView ì¬ì„¤ì • (Enhanced ìš°ì„ )
  useEffect(() => {
    if (hasEnhancedSchema) {
      setSchemaView('enhanced');
    } else {
      setSchemaView('original');
    }
  }, [endpoint.id, hasEnhancedSchema]);
  
  // Initialize editable schema
  useEffect(() => {
    // ğŸ”¥ ì´ë¯¸ ìˆ˜ì • ì¤‘ì¸ ê²½ìš° ì´ˆê¸°í™”í•˜ì§€ ì•ŠìŒ (íƒ­ ì „í™˜ ëŒ€ì‘)
    if (isSchemaModified && editableSchema) {
      return;
    }
    
    if (schemaView === 'original') {
      setEditableSchema(JSON.stringify(spec.jsonSchema, null, 2));
    } else {
      setEditableSchema(
        spec.jsonSchemaEnhanced 
          ? JSON.stringify(spec.jsonSchemaEnhanced, null, 2)
          : '// Enhanced schema not available yet\n// Add enhanced schema to apiSpecs data'
      );
    }
    setIsSchemaModified(false);
  }, [schemaView, endpoint.id]); // endpoint.idë¡œ ë³€ê²½
  
  // Handle schema changes
  const handleSchemaChange = (value: string) => {
    setEditableSchema(value);
    setIsSchemaModified(true);
  };
  
  // Parse and validate JSON
  const getSchemaForDisplay = () => {
    try {
      if (isSchemaModified) {
        return JSON.parse(editableSchema);
      }
    } catch (e) {
      // If invalid JSON, return the original
    }
    return schemaView === 'original' ? spec.jsonSchema : spec.jsonSchemaEnhanced;
  };
  
  // ğŸ¯ Display parameters - ì´ì œ tableParameters ì§ì ‘ ì‚¬ìš©
  const displayParameters = tableParameters;
    if (!enhancedSchema) return [];
    
    const params: any[] = [];
    let paramNo = 1;
    
    // ğŸ”¥ ë²”ìš©: ë£¨íŠ¸ í‚¤ ì°¾ê¸° (TABLE, NLCT ë“±)
    const rootKey = Object.keys(enhancedSchema).find(key => key !== '$schema' && key !== 'title');
    if (!rootKey) return [];
    
    const schema = enhancedSchema[rootKey];
    
    // ğŸ”¥ ì¤‘ì²© êµ¬ì¡° ì§€ì›: Argumentê°€ ìˆìœ¼ë©´ ê·¸ ì•ˆì— propertiesê°€ ìˆìŒ
    let properties = schema.properties || {};
    let baseRequired = schema.required || [];
    let allOfConditions = schema.allOf || [];
    
    // TABLE ìŠ¤í‚¤ë§ˆì²˜ëŸ¼ Argument ë ˆë²¨ì´ ìˆëŠ” ê²½ìš°
    if (properties.Argument && properties.Argument.properties) {
      const argSchema = properties.Argument;
      properties = argSchema.properties;
      baseRequired = argSchema.required || [];
      allOfConditions = argSchema.allOf || [];
    }
    
    // ğŸ¯ allOf ì¡°ê±´ë¶€ required í•„ë“œ ë§¤í•‘ íŒŒì‹±
    const conditionalRequiredMap: Record<string, string[]> = {};
    const sectionNameMap: Record<string, string> = {};
    
    allOfConditions.forEach((condition: any) => {
      if (condition.if && condition.then) {
        // ëª¨ë“  ê°€ëŠ¥í•œ ì¡°ê±´ë¶€ í‚¤ ì°¾ê¸°
        const conditionProps = condition.if.properties || {};
        const conditionKey = Object.keys(conditionProps)[0];
        const conditionValue = conditionProps[conditionKey]?.const;
        
        if (conditionValue && condition.then.required) {
          conditionalRequiredMap[conditionValue] = condition.then.required;
          // ì„¹ì…˜ ì´ë¦„ì„ ì¡°ê±´ë¶€ ê°’ìœ¼ë¡œ ì„¤ì • (ë” ì½ê¸° ì‰½ê²Œ)
          sectionNameMap[conditionValue] = `${conditionKey}: ${conditionValue}`;
        }
      }
    });
    
    // ğŸ¯ í•„ë“œë¥¼ ì¡°ê±´ë³„ë¡œ ë¶„ë¥˜
    const commonFields: string[] = [];
    const conditionalFieldsMap: Record<string, string[]> = {};
    
    // conditionalRequiredMapì˜ ëª¨ë“  í‚¤ë¥¼ ë¯¸ë¦¬ ì´ˆê¸°í™”
    Object.keys(conditionalRequiredMap).forEach(method => {
      conditionalFieldsMap[method] = [];
    });
    
    Object.keys(properties).forEach(key => {
      // ì¡°ê±´ë¶€ requiredë¥¼ í™•ì¸
      let isConditional = false;
      for (const [method, requiredFields] of Object.entries(conditionalRequiredMap)) {
        if (requiredFields.includes(key) && !baseRequired.includes(key)) {
          if (!conditionalFieldsMap[method]) {
            conditionalFieldsMap[method] = [];
          }
          conditionalFieldsMap[method].push(key);
          isConditional = true;
        }
      }
      if (!isConditional) {
        commonFields.push(key);
      }
    });
    
    // ğŸ¯ 1. ê³µí†µ í•„ë“œ ì¶”ê°€
    commonFields.forEach(key => {
      const prop = properties[key];
      const isRequired = baseRequired.includes(key);
      params.push(createParameter(key, prop, isRequired, paramNo++));
    });
    
    // ğŸ¯ 2. ì¡°ê±´ë¶€ í•„ë“œë¥¼ ì„¹ì…˜ë³„ë¡œ ì¶”ê°€
    Object.keys(conditionalFieldsMap).forEach(method => {
      const fieldsForMethod = conditionalFieldsMap[method];
      if (fieldsForMethod.length > 0) {
        // ì„¹ì…˜ í—¤ë” ì¶”ê°€
        params.push({ section: sectionNameMap[method] || `Conditional: ${method}` });
        
        // í•´ë‹¹ ë©”ì†Œë“œì˜ ì¡°ê±´ë¶€ required í•„ë“œ ëª©ë¡
        const methodRequired = conditionalRequiredMap[method] || [];
        
        // í•„ë“œ ì¶”ê°€
        fieldsForMethod.forEach(key => {
          const prop = properties[key];
          const isRequired = methodRequired.includes(key);
          params.push(createParameter(key, prop, isRequired, paramNo++));
        });
      }
    });
    
    return params;
    
    // Helper function to create parameter
    function createParameter(key: string, prop: any, isRequired: boolean, no: number) {
      // Determine type
      let type = prop.type || 'string';
      if (type === 'integer') type = 'Integer';
      else if (type === 'number') type = 'Number';
      else if (type === 'string') type = 'String';
      else if (type === 'boolean') type = 'Boolean';
      else if (type === 'object') type = 'Object';
      else if (type === 'array') {
        const itemType = prop.items?.type || 'object';
        if (itemType === 'object') {
          type = 'Array[Object]';
        } else if (itemType === 'string') {
          type = 'Array[String]';
        } else if (itemType === 'integer' || itemType === 'number') {
          type = 'Array[Number]';
        } else {
          type = `Array[${itemType}]`;
        }
      }
      
      // Get default value
      let defaultValue = '-';
      if (prop.default !== undefined) {
        if (typeof prop.default === 'string') {
          defaultValue = prop.default === '' ? '""' : `"${prop.default}"`;
        } else if (typeof prop.default === 'boolean') {
          defaultValue = prop.default.toString();
        } else if (Array.isArray(prop.default)) {
          defaultValue = JSON.stringify(prop.default);
        } else if (typeof prop.default === 'object') {
          defaultValue = JSON.stringify(prop.default);
        } else {
          defaultValue = String(prop.default);
        }
      }
      
      // Get options from enum
      const options = prop.enum || [];
      
      // Build description
      let description = prop.description || key;
      
      const param: any = {
        no,
        name: key,
        description,
        type,
        default: defaultValue,
        required: isRequired ? 'Required' : 'Optional',
      };
      
      // ğŸ”¥ Options formatting - ë²”ìš© enum ì²˜ë¦¬
      if (options.length > 0) {
        param.options = options.map((opt: any) => {
          if (typeof opt === 'string') {
            return ` â€¢ "${opt}"`;
          } else if (typeof opt === 'number') {
            return ` â€¢ ${opt}`;
          } else {
            return ` â€¢ ${JSON.stringify(opt)}`;
          }
        });
      }
      
      // ğŸ”¥ Handle object properties (nested fields)
      if (prop.type === 'object' && prop.properties) {
        const objProps = prop.properties;
        const objRequired = prop.required || [];
        const children: any[] = [];
        
        Object.keys(objProps).forEach((childKey, idx) => {
          const childProp = objProps[childKey];
          let childType = childProp.type || 'string';
          if (childType === 'integer') childType = 'Integer';
          else if (childType === 'number') childType = 'Number';
          else if (childType === 'string') childType = 'String';
          else if (childType === 'boolean') childType = 'Boolean';
          else if (childType === 'object') childType = 'Object';
          else if (childType === 'array') {
            const itemType = childProp.items?.type || 'object';
            childType = `Array[${itemType === 'object' ? 'Object' : itemType === 'integer' ? 'Number' : itemType}]`;
          }
          
          const childIsRequired = objRequired.includes(childKey);
          let childDefault = '-';
          if (childProp.default !== undefined) {
            if (typeof childProp.default === 'string') {
              childDefault = childProp.default === '' ? '""' : `"${childProp.default}"`;
            } else if (Array.isArray(childProp.default)) {
              childDefault = JSON.stringify(childProp.default);
            } else if (typeof childProp.default === 'object') {
              childDefault = JSON.stringify(childProp.default);
            } else {
              childDefault = String(childProp.default);
            }
          }
          
          let childDesc = childProp.description || childKey;
          const childOptions = childProp.enum || [];
          
          const child: any = {
            no: `(${idx + 1})`,
            name: childKey,
            description: childDesc,
            type: childType,
            default: childDefault,
            required: childIsRequired ? 'Required' : 'Optional',
          };
          
          if (childOptions.length > 0) {
            child.options = childOptions.map((opt: any) => {
              if (typeof opt === 'string') {
                return ` â€¢ "${opt}"`;
              } else {
                return ` â€¢ ${opt}`;
              }
            });
          }
          
          children.push(child);
        });
        
        if (children.length > 0) {
          param.children = children;
        }
      }
      
      // ğŸ”¥ Handle array items (children)
      if (prop.type === 'array' && prop.items?.type === 'object') {
        const itemProps = prop.items.properties || {};
        const itemRequired = prop.items.required || [];
        const children: any[] = [];
        
        Object.keys(itemProps).forEach((childKey, idx) => {
          const childProp = itemProps[childKey];
          let childType = childProp.type || 'string';
          if (childType === 'integer') childType = 'Integer';
          else if (childType === 'number') childType = 'Number';
          else if (childType === 'string') childType = 'String';
          else if (childType === 'boolean') childType = 'Boolean';
          else if (childType === 'object') childType = 'Object';
          else if (childType === 'array') {
            const itemType = childProp.items?.type || 'object';
            childType = `Array[${itemType === 'integer' ? 'Number' : itemType}]`;
          }
          
          const childIsRequired = itemRequired.includes(childKey);
          let childDefault = '-';
          if (childProp.default !== undefined) {
            if (typeof childProp.default === 'string') {
              childDefault = childProp.default === '' ? '""' : `"${childProp.default}"`;
            } else if (Array.isArray(childProp.default)) {
              childDefault = JSON.stringify(childProp.default);
            } else if (typeof childProp.default === 'object') {
              childDefault = JSON.stringify(childProp.default);
            } else {
              childDefault = String(childProp.default);
            }
          }
          
          let childDesc = childProp.description || childKey;
          const childOptions = childProp.enum || [];
          
          const child: any = {
            no: `(${idx + 1})`,
            name: childKey,
            description: childDesc,
            type: childType,
            default: childDefault,
            required: childIsRequired ? 'Required' : 'Optional',
          };
          
          if (childOptions.length > 0) {
            child.options = childOptions.map((opt: any) => {
              if (typeof opt === 'string') {
                return ` â€¢ "${opt}"`;
              } else {
                return ` â€¢ ${opt}`;
              }
            });
          }
          
          children.push(child);
        });
        
        if (children.length > 0) {
          param.children = children;
        }
      }
      
      return param;
    }
  };

  const toggleParam = (paramNo: number) => {
    setExpandedParams((prev) => {
      const next = new Set(prev);
      if (next.has(paramNo)) {
        next.delete(paramNo);
      } else {
        next.add(paramNo);
      }
      return next;
    });
  };

  // ğŸ¯ Send to Manual í•¨ìˆ˜
  const handleSendToManual = () => {
    // JSON Schemaë¥¼ ìƒ‰ìƒ ìˆëŠ” HTMLë¡œ ë³€í™˜
    const formatJsonSchemaToHTML = (schema: any): string => {
      const jsonStr = JSON.stringify(schema, null, 2);
      return jsonStr
        .split('\n')
        .map(line => {
          // ê³µë°±ì„ &nbsp;ë¡œ ë³€í™˜í•˜ì—¬ ë“¤ì—¬ì“°ê¸° ìœ ì§€
          const leadingSpaces = line.match(/^(\s*)/)?.[1] || '';
          const indent = leadingSpaces.replace(/ /g, '&nbsp;&nbsp;');
          const trimmedLine = line.trim();
          
          // í‚¤-ê°’ íŒ¨í„´ ë§¤ì¹­
          const keyMatch = trimmedLine.match(/^"([^"]+)":\s*(.+)$/);
          if (keyMatch) {
            const key = keyMatch[1];
            let value = keyMatch[2];
            const hasComma = value.endsWith(',');
            if (hasComma) {
              value = value.slice(0, -1); // ì½¤ë§ˆ ì œê±°
            }
            
            // ê°’ì˜ íƒ€ì…ì— ë”°ë¼ ìƒ‰ìƒ ì ìš©
            let styledValue = value;
            if (value === 'true' || value === 'false') {
              // Boolean ê°’
              styledValue = `<span style="color: #055bcc; font-weight: bold;">${value}</span>`;
            } else if (value.match(/^"[^"]*"$/)) {
              // ë¬¸ìì—´ ê°’
              styledValue = `<span style="color: #055bcc;">${value}</span>`;
            } else if (value.match(/^-?\d+(\.\d+)?$/)) {
              // ìˆ«ì ê°’
              styledValue = `<span style="color: #0ab66c;">${value}</span>`;
            } else if (value === '{' || value === '[') {
              // ì—¬ëŠ” ì¤‘ê´„í˜¸/ëŒ€ê´„í˜¸ëŠ” ê·¸ëŒ€ë¡œ
              styledValue = value;
            }
            
            // í‚¤ ìŠ¤íƒ€ì¼ë§ + ê°’
            const styledLine = `${indent}<span style="color: #c31b1b;">"${key}"</span>: ${styledValue}${hasComma ? ',' : ''}`;
            return styledLine;
          }
          
          // ì¤‘ê´„í˜¸, ëŒ€ê´„í˜¸ë§Œ ìˆëŠ” ë¼ì¸
          if (trimmedLine.match(/^[{\[\}\]],?$/)) {
            return indent + trimmedLine;
          }
          
          // ê·¸ ì™¸ì˜ ê²½ìš° (ì¼ë°˜ í…ìŠ¤íŠ¸)
          return indent + trimmedLine;
        })
        .join('<br>');
    };

    // Specifications í…Œì´ë¸”ì„ HTMLë¡œ ë³€í™˜
    const generateSpecificationsTable = (): string => {
      // ğŸ”¥ NEW: ì´ë¯¸ ê³„ì‚°ëœ tableParameters ì‚¬ìš©
      const params = tableParameters;
        
      if (!params || params.length === 0) {
        return '<p>No parameters available</p>';
      }

      let tableHTML = `
<div class="table-wrap">
<table style="border-collapse: collapse; width: 100%;" border="1">
<colgroup> 
  <col style="width: 6.00%;"> 
  <col style="width: 6.00%;"> 
  <col style="width: 44.00%;"> 
  <col style="width: 14.00%;"> 
  <col style="width: 10.00%;"> 
  <col style="width: 10.00%;"> 
  <col style="width: 10.00%;"> 
</colgroup>
<tbody>
<tr>
<th style="padding: 15px 5px 15px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">No.</th>
<th style="padding: 15px 5px 15px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;" colspan="2">Description</th>
<th style="padding: 15px 5px 15px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">Key</th>
<th style="padding: 15px 5px 15px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">Value Type</th>
<th style="padding: 15px 5px 15px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">Default</th>
<th style="padding: 15px 5px 15px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">Required</th>
</tr>`;

      params.forEach((param: any) => {
        // ì„¹ì…˜ í–‰
        if (param.section) {
          tableHTML += `
<tr>
<td style="background-color: #e6fcff; padding: 10px 5px 10px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;" colspan="7">
<p><span style="color: #4c9aff;">${param.section}</span></p>
</td>
</tr>`;
        }

        // íŒŒë¼ë¯¸í„° í–‰
        const rowspan = param.children ? param.children.length + 1 : 1;
        tableHTML += `
<tr>
<td style="padding: 10px 5px 10px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;" ${param.children ? `rowspan="${rowspan}"` : ''}>
<p style="text-align: center;">${param.no}</p>
</td>
<td style="padding: 10px 5px 10px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;" colspan="2">
<p>${param.description || param.name}</p>
${param.options ? param.options.map((opt: string) => `<p>${opt}</p>`).join('') : ''}
</td>
<td style="padding: 10px 5px 10px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
<p style="text-align: center;">"${param.name}"</p>
</td>
<td style="padding: 10px 5px 10px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
<p style="text-align: center;">${param.type}</p>
</td>
<td style="padding: 10px 5px 10px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
<p style="text-align: center;">${param.default || '-'}</p>
</td>
<td style="padding: 10px 5px 10px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
<p style="text-align: center;">${param.required}</p>
</td>
</tr>`;

        // ìì‹ íŒŒë¼ë¯¸í„°
        if (param.children) {
          param.children.forEach((child: any, idx: number) => {
            tableHTML += `
<tr>
<td style="padding: 10px 5px 10px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
<p style="text-align: center;">(${idx + 1})</p>
</td>
<td style="padding: 10px 5px 10px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
<p>${child.description || child.name}</p>
${child.options ? child.options.map((opt: string) => `<p>${opt}</p>`).join('') : ''}
</td>
<td style="padding: 10px 5px 10px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
<p style="text-align: center;">"${child.name}"</p>
</td>
<td style="padding: 10px 5px 10px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
<p style="text-align: center;">${child.type}</p>
</td>
<td style="padding: 10px 5px 10px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
<p style="text-align: center;">${child.default || '-'}</p>
</td>
<td style="padding: 10px 5px 10px 5px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
<p style="text-align: center;">${child.required}</p>
</td>
</tr>`;
          });
        }
      });

      tableHTML += `
</tbody>
</table>
</div>`;
      
      return tableHTML;
    };

    // ğŸ¯ í˜„ì¬ í¸ì§‘ ì¤‘ì´ê±°ë‚˜ ì €ì¥ëœ ìŠ¤í‚¤ë§ˆ ì‚¬ìš©
    const currentSchema = savedSchema || getSchemaForDisplay();
    const originalSchemaHTML = formatJsonSchemaToHTML(spec.jsonSchema);
    const enhancedSchemaHTML = spec.jsonSchemaEnhanced 
      ? formatJsonSchemaToHTML(spec.jsonSchemaEnhanced) 
      : null;
    
    // í˜„ì¬ ë³´ê³  ìˆëŠ” ìŠ¤í‚¤ë§ˆë¥¼ HTMLë¡œ ë³€í™˜
    const currentSchemaHTML = formatJsonSchemaToHTML(currentSchema);

    const newManualData: ManualData = {
      title: spec.title || endpoint.name,
      category: endpoint.method,
      inputUri: endpoint.path, // endpoint.path ì‚¬ìš©
      activeMethods: endpoint.method, // endpoint.method ì‚¬ìš©
      jsonSchema: currentSchemaHTML, // í˜„ì¬ ë³´ê³  ìˆëŠ” ìŠ¤í‚¤ë§ˆ ì‚¬ìš©
      jsonSchemaOriginal: originalSchemaHTML,
      jsonSchemaEnhanced: enhancedSchemaHTML || undefined,
      examples: manualData?.examples || [],
      specifications: generateSpecificationsTable(),
    };

    setManualData(newManualData);
    
    const schemaType = spec.jsonSchemaEnhanced ? 'Enhanced' : 'Original';
    alert(`âœ… Spec data sent to Manual tab!\nğŸ“‹ Schema Type: ${schemaType}`);
  };

  return (
    <ResizablePanelGroup direction="horizontal" className="h-full w-full">
      {/* Left Pane - JSON Schema Editor */}
      <ResizablePanel defaultSize={50} minSize={30}>
        <div className="h-full flex flex-col bg-zinc-950 overflow-hidden">
          <div className="p-4 border-b border-zinc-800 bg-zinc-900 flex-shrink-0">
            <div className="flex items-center justify-between mb-2">
              <h3 className="text-sm">JSON Schema</h3>
              
              {/* Schema Toggle */}
              <div className="flex items-center gap-1 bg-zinc-800 rounded-lg p-1">
                <button
                  onClick={() => setSchemaView('original')}
                  className={`px-3 py-1 text-xs rounded transition-colors ${
                    schemaView === 'original'
                      ? 'bg-blue-600 text-white'
                      : 'text-zinc-400 hover:text-zinc-200'
                  }`}
                >
                  Original
                </button>
                <button
                  onClick={() => setSchemaView('enhanced')}
                  className={`px-3 py-1 text-xs rounded transition-colors ${
                    schemaView === 'enhanced'
                      ? 'bg-green-600 text-white'
                      : 'text-zinc-400 hover:text-zinc-200'
                  }`}
                >
                  Enhanced
                </button>
              </div>
            </div>
            <p className="text-xs text-zinc-500">
              {schemaView === 'original' 
                ? 'Original schema definition (editable)' 
                : 'Enhanced with conditions, required, and optional fields (editable)'}
            </p>
          </div>

          {/* Monaco Editor - Full Height */}
          <div className="flex-1 relative">
            <CodeEditor
              value={editableSchema}
              onChange={(value) => handleSchemaChange(value || '')}
              language="json"
              minimap={true}
            />
            
            {/* Modified Indicator */}
            {isSchemaModified && (
              <div className="absolute top-4 right-4 px-2 py-1 bg-orange-600/20 border border-orange-600/50 rounded text-xs text-orange-400 z-10">
                Modified
              </div>
            )}
          </div>
          
          {/* Footer with Save Button */}
          <div className="border-t border-zinc-800 bg-zinc-900 p-4 flex items-center justify-between flex-shrink-0">
            <div className="flex items-center gap-2 text-xs text-zinc-500">
              {isSchemaModified ? (
                <>
                  <div className="w-2 h-2 bg-orange-500 rounded-full animate-pulse"></div>
                  <span>Unsaved changes</span>
                </>
              ) : (
                <>
                  <div className="w-2 h-2 bg-green-500 rounded-full"></div>
                  <span>All changes saved</span>
                </>
              )}
            </div>
            
            <div className="flex items-center gap-2">
              <Button
                onClick={() => {
                  // Reset to original
                  if (schemaView === 'original') {
                    setEditableSchema(JSON.stringify(spec.jsonSchema, null, 2));
                  } else {
                    setEditableSchema(
                      spec.jsonSchemaEnhanced 
                        ? JSON.stringify(spec.jsonSchemaEnhanced, null, 2)
                        : '// Enhanced schema not available yet\n// Add enhanced schema to apiSpecs data'
                    );
                  }
                  setIsSchemaModified(false);
                }}
                variant="outline"
                size="sm"
                disabled={!isSchemaModified}
                className="h-8 text-xs"
              >
                Reset
              </Button>
              
              <Button
                onClick={async () => {
                  try {
                    // Validate JSON
                    const parsedSchema = JSON.parse(editableSchema);
                    
                    if (!currentVersionId) {
                      alert(`âš ï¸ No version selected!\n\nğŸ“ To save:\n1. Go to Version tab\n2. Create or load a version\n3. Come back and save again`);
                      return;
                    }
                    
                    // ğŸ¯ í˜„ì¬ ë²„ì „ ê°€ì ¸ì˜¤ê¸°
                    const currentVersion = getCurrentVersion();
                    if (!currentVersion) {
                      alert('âŒ Failed to get current version!');
                      return;
                    }
                    
                    const currentSpecData = currentVersion.specData || {
                      jsonSchema: {},
                      jsonSchemaOriginal: null,
                      jsonSchemaEnhanced: null,
                      specifications: '',
                    };
                    
                    // ğŸ”¥ ì—…ë°ì´íŠ¸í•  specData ì¤€ë¹„ (ê°ì²´ í˜•íƒœ)
                    // ğŸ¯ Originalê³¼ Enhancedë¥¼ ê°ê° ë³„ë„ë¡œ ê´€ë¦¬
                    const updatedSpecData = {
                      // jsonSchemaëŠ” í•­ìƒ ìµœì‹  ê°’ì„ ìœ ì§€ (Enhancedê°€ ìˆìœ¼ë©´ Enhanced, ì—†ìœ¼ë©´ Original)
                      jsonSchema: schemaView === 'enhanced' 
                        ? parsedSchema 
                        : schemaView === 'original'
                          ? parsedSchema
                          : (currentSpecData.jsonSchema || {}),
                      // Original ìŠ¤í‚¤ë§ˆ: Original íƒ­ì—ì„œ ì €ì¥ ì‹œì—ë§Œ ì—…ë°ì´íŠ¸
                      jsonSchemaOriginal: schemaView === 'original'
                        ? parsedSchema
                        : currentSpecData.jsonSchemaOriginal,
                      // Enhanced ìŠ¤í‚¤ë§ˆ: Enhanced íƒ­ì—ì„œ ì €ì¥ ì‹œì—ë§Œ ì—…ë°ì´íŠ¸
                      jsonSchemaEnhanced: schemaView === 'enhanced'
                        ? parsedSchema
                        : currentSpecData.jsonSchemaEnhanced,
                      specifications: currentSpecData.specifications || '',
                    };
                    
                    // ğŸ”¥ 1. Zustand store ì—…ë°ì´íŠ¸ (ë©”ëª¨ë¦¬)
                    updateSpecData(updatedSpecData);
                    
                    // ğŸ”¥ 2. ë°±ì—”ë“œ API í˜¸ì¶œ (ì˜êµ¬ ì €ì¥) - ë¬¸ìì—´ë¡œ ë³€í™˜
                    const response = await apiClient.updateVersion(currentVersionId, {
                      specData: {
                        jsonSchema: JSON.stringify(updatedSpecData.jsonSchema),
                        jsonSchemaOriginal: updatedSpecData.jsonSchemaOriginal 
                          ? JSON.stringify(updatedSpecData.jsonSchemaOriginal) 
                          : undefined,
                        jsonSchemaEnhanced: updatedSpecData.jsonSchemaEnhanced 
                          ? JSON.stringify(updatedSpecData.jsonSchemaEnhanced) 
                          : undefined,
                        specifications: updatedSpecData.specifications,
                      },
                    });
                    
                    if (!response.data) {
                      throw new Error('Backend save failed');
                    }
                    
                    // ğŸ”¥ 3. ì €ì¥ëœ ìŠ¤í‚¤ë§ˆ state ì—…ë°ì´íŠ¸ (í…Œì´ë¸” ë¦¬ë Œë”ë§ íŠ¸ë¦¬ê±°)
                    setSavedSchema(parsedSchema);
                    
                    // ğŸ”¥ 4. ë²„ì „ ëª©ë¡ë„ ë‹¤ì‹œ fetch (í”„ë¡ íŠ¸ ì¬ì‹œì‘ ì‹œ ìµœì‹  ë°ì´í„° ë¡œë“œ)
                    if (endpoint?.id) {
                      await fetchVersions(endpoint.id);
                      // ë²„ì „ ëª©ë¡ì„ ë‹¤ì‹œ ë¶ˆëŸ¬ì˜¨ í›„, ê°™ì€ ë²„ì „ì„ ë‹¤ì‹œ ë¡œë“œ
                      await loadVersion(currentVersionId);
                    }
                    
                    setIsSchemaModified(false);
                    alert(`âœ… Schema saved!\n\nğŸ’¾ Database: ${currentVersion.version}\nâœ¨ Restart safe!`);
                  } catch (error) {
                    console.error('Save failed:', error);
                    alert(`âŒ Save failed!\n\n${error instanceof Error ? error.message : 'Unknown error'}`);
                  }
                }}
                size="sm"
                disabled={!isSchemaModified}
                className="h-8 text-xs bg-blue-600 hover:bg-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <Save className="w-3 h-3 mr-2" />
                Save Schema
              </Button>
            </div>
          </div>
        </div>
      </ResizablePanel>

      <ResizableHandle />

      {/* Right Pane - Visual Schema Grid (Table) */}
      <ResizablePanel defaultSize={50} minSize={30}>
        <div className="h-full flex flex-col bg-zinc-950 overflow-hidden">
          <div className="p-4 border-b border-zinc-800 bg-zinc-900 flex-shrink-0 flex items-center justify-between">
            <div>
              <h3 className="text-sm mb-1">Visual Schema Grid</h3>
              <p className="text-xs text-zinc-500">API specification and parameters</p>
            </div>
            <Button
              onClick={handleSendToManual}
              size="sm"
              className="bg-blue-600 hover:bg-blue-500 h-8"
            >
              <Send className="w-3 h-3 mr-2" />
              Send to Manual
            </Button>
          </div>

          <ScrollArea className="flex-1 h-0">
            <div className="p-6 space-y-6">
              <div>
                <h2 className="text-2xl mb-2">{spec.title}</h2>
                <div className="flex items-center gap-3 mb-2">
                  <span className="px-3 py-1 bg-blue-600 text-white text-sm rounded">
                    {endpoint.method}
                  </span>
                  <code className="text-sm text-zinc-400 font-mono">{spec.uri || endpoint.path}</code>
                </div>
                {spec.methods && (
                  <div className="text-xs text-zinc-500">
                    Active Methods: {spec.methods.join(', ')}
                  </div>
                )}
              </div>

              <div className="space-y-4">
                <section>
                  <h3 className="text-lg mb-3">Description</h3>
                  <p className="text-zinc-400 text-sm leading-relaxed">{spec.description}</p>
                </section>

                <section>
                  <h3 className="text-lg mb-3">Parameters</h3>
                  <div className="border border-zinc-800 rounded-lg overflow-hidden">
                    <table className="w-full text-sm">
                      <thead className="bg-zinc-900">
                        <tr>
                          <th className="text-left p-3 border-b border-zinc-800">No.</th>
                          <th className="text-left p-3 border-b border-zinc-800">Field Name</th>
                          <th className="text-left p-3 border-b border-zinc-800">Type</th>
                          <th className="text-left p-3 border-b border-zinc-800">Default</th>
                          <th className="text-left p-3 border-b border-zinc-800">Required</th>
                        </tr>
                      </thead>
                      <tbody>
                        {displayParameters.map((param: any, idx: number) => {
                          const rows = [];
                          
                          // Add section row if exists
                          if (param.section) {
                            rows.push(
                              <tr key={`section-${param.no}-${idx}`} className="bg-cyan-950/30 border-b border-zinc-800">
                                <td colSpan={5} className="p-2 text-cyan-400 font-semibold text-xs">
                                  {param.section}
                                </td>
                              </tr>
                            );
                          }
                          
                          // Add main parameter row
                          rows.push(
                            <tr key={`param-${param.no}-${idx}`} className="border-b border-zinc-800">
                              <td className="p-3 text-zinc-400">{param.no}</td>
                              <td className="p-3 pl-9 relative">
                                {param.children && (
                                  <button
                                    onClick={() => toggleParam(param.no)}
                                    className="absolute left-3 top-3.5 w-4 h-4 flex items-center justify-center hover:text-blue-400 transition-colors"
                                  >
                                    {expandedParams.has(param.no) ? (
                                      <ChevronDown className="w-4 h-4" />
                                    ) : (
                                      <ChevronRight className="w-4 h-4" />
                                    )}
                                  </button>
                                )}
                                <div>
                                  <div className="font-mono text-blue-400">{param.name}</div>
                                  {param.description && (
                                    <div className="text-xs text-zinc-500 mt-0.5">{param.description}</div>
                                  )}
                                </div>
                                {param.options && (
                                  <div className="text-xs text-zinc-600 mt-1">
                                    {param.options.map((opt: string, optIdx: number) => (
                                      <div key={`${param.name}-opt-${optIdx}`}>â€¢ {opt}</div>
                                    ))}
                                  </div>
                                )}
                              </td>
                              <td className="p-3 text-zinc-400">{param.type}</td>
                              <td className="p-3 text-zinc-500 font-mono text-xs">{param.default}</td>
                              <td className="p-3">
                                <span
                                  className={`px-2 py-0.5 text-xs rounded ${
                                    param.required === 'Required'
                                      ? 'bg-red-600/20 text-red-400'
                                      : 'bg-zinc-700/50 text-zinc-400'
                                  }`}
                                >
                                  {param.required}
                                </span>
                              </td>
                            </tr>
                          );
                          
                          // Add child rows if expanded
                          if (param.children && expandedParams.has(param.no)) {
                            param.children.forEach((child: any, childIdx: number) => {
                              rows.push(
                                <tr key={`child-${param.no}-${childIdx}`} className="border-b border-zinc-800 bg-zinc-900/50">
                                  <td className="p-3"></td>
                                  <td className="p-3 pl-8">
                                    <div className="font-mono text-amber-400">â””â”€ {child.name}</div>
                                    {child.options && (
                                      <div className="text-xs text-zinc-600 mt-1">
                                        {child.options.map((opt: string, optIdx: number) => (
                                          <div key={`${child.name}-opt-${optIdx}`}>â€¢ {opt}</div>
                                        ))}
                                      </div>
                                    )}
                                  </td>
                                  <td className="p-3 text-zinc-400">{child.type}</td>
                                  <td className="p-3 text-zinc-500 font-mono text-xs">{child.default}</td>
                                  <td className="p-3">
                                    <span
                                      className={`px-2 py-0.5 text-xs rounded ${
                                        child.required === 'Required'
                                          ? 'bg-red-600/20 text-red-400'
                                          : 'bg-zinc-700/50 text-zinc-400'
                                      }`}
                                    >
                                      {child.required}
                                    </span>
                                  </td>
                                </tr>
                              );
                            });
                          }
                          
                          return rows;
                        })}
                      </tbody>
                    </table>
                  </div>
                </section>
              </div>
            </div>
          </ScrollArea>
        </div>
      </ResizablePanel>
    </ResizablePanelGroup>
  );
}