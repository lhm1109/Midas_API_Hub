/**
 * Accuracy Validator
 * Evidence-based validation and auto-question generation
 */

import type {
    AccuracyPolicy,
    AutoQuestionPattern,
    ValidationResult,
    ValidationError,
    ValidationWarning,
    AutoGeneratedQuestion,
    Evidence
} from '../types/accuracy-types.js';

/**
 * Validate schema against accuracy policy
 */
export function validateWithAccuracyPolicy(
    schema: Record<string, unknown>,
    policy: AccuracyPolicy
): ValidationResult {
    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];
    const autoQuestions: AutoGeneratedQuestion[] = [];

    // Extract schema properties
    const properties = extractProperties(schema);

    // Check evidence requirements
    for (const field of Object.keys(properties)) {
        const fieldSchema = properties[field];
        const evidenceErrors = validateFieldEvidence(field, fieldSchema, policy);
        errors.push(...evidenceErrors);
    }

    // Detect auto-question patterns
    for (const pattern of policy.autoQuestionPatterns) {
        const questions = detectPattern(schema, properties, pattern);
        autoQuestions.push(...questions);
    }

    // Calculate evidence coverage
    const evidenceCoverage = calculateEvidenceCoverage(properties, policy);

    // Check quality gates
    const gateErrors = checkQualityGates(schema, policy, evidenceCoverage, autoQuestions.length);
    errors.push(...gateErrors);

    return {
        passed: errors.length === 0,
        errors,
        warnings,
        autoQuestions,
        evidenceCoverage
    };
}

/**
 * Extract properties from schema (handle wrappers)
 */
function extractProperties(schema: Record<string, unknown>): Record<string, any> {
    // Check for Assign/Argument wrapper
    const properties = schema.properties as Record<string, any> || {};

    if (properties.Assign?.properties) {
        return properties.Assign.properties;
    }
    if (properties.Argument?.properties) {
        return properties.Argument.properties;
    }

    return properties;
}

/**
 * Validate evidence for a single field
 */
function validateFieldEvidence(
    fieldName: string,
    fieldSchema: any,
    policy: AccuracyPolicy
): ValidationError[] {
    const errors: ValidationError[] = [];

    // Check if field type requires evidence
    const requiresEvidence = shouldRequireEvidence(fieldSchema, policy);
    if (!requiresEvidence) return errors;

    // Check for x-evidence marker
    const evidence = fieldSchema['x-evidence'] as Evidence | undefined;

    if (!evidence) {
        // No evidence provided
        const action = getActionForMissingEvidence(fieldSchema, policy);
        if (action === 'reject') {
            errors.push({
                field: fieldName,
                type: 'missing_evidence',
                message: `Evidence required for field with ${getEvidenceRequirementReason(fieldSchema, policy)}`,
                severity: 'error'
            });
        }
        return errors;
    }

    // Validate evidence format
    const formatErrors = validateEvidenceFormat(fieldName, evidence, policy);
    errors.push(...formatErrors);

    // Check confidence level
    if (evidence.confidence === 'low' && policy.validationStrictness.lowConfidenceEvidence.action === 'generate_question') {
        // This will be handled by auto-question generation
    }

    return errors;
}

/**
 * Check if field should require evidence
 */
function shouldRequireEvidence(fieldSchema: any, policy: AccuracyPolicy): boolean {
    const requirements = policy.requireEvidenceFor;

    // Check for enum
    if (requirements.includes('enum') && (fieldSchema.enum || fieldSchema.items?.enum)) {
        return true;
    }

    // Check for oneOf
    if (requirements.includes('oneOf') && fieldSchema.oneOf) {
        return true;
    }

    // Check for default value
    if (requirements.includes('defaultValue') && fieldSchema.default !== undefined) {
        return true;
    }

    // Check for enumLabelsByType
    if (requirements.includes('enumLabelsByType') && fieldSchema['x-enum-labels-by-type']) {
        return true;
    }

    return false;
}

/**
 * Get action for missing evidence
 */
function getActionForMissingEvidence(fieldSchema: any, policy: AccuracyPolicy): 'reject' | 'warn' | 'allow' {
    if (fieldSchema.enum || fieldSchema.items?.enum) {
        return policy.validationStrictness.missingEvidenceForEnum.action;
    }
    if (fieldSchema.default !== undefined) {
        return policy.validationStrictness.missingEvidenceForDefault.action;
    }
    return 'warn';
}

/**
 * Get reason for evidence requirement
 */
function getEvidenceRequirementReason(fieldSchema: any, policy: AccuracyPolicy): string {
    if (fieldSchema.enum || fieldSchema.items?.enum) return 'enum values';
    if (fieldSchema.oneOf) return 'oneOf options';
    if (fieldSchema.default !== undefined) return 'default value';
    if (fieldSchema['x-enum-labels-by-type']) return 'type-specific enum labels';
    return 'unknown field type';
}

/**
 * Validate evidence format
 */
function validateEvidenceFormat(
    fieldName: string,
    evidence: Evidence,
    policy: AccuracyPolicy
): ValidationError[] {
    const errors: ValidationError[] = [];

    // Check source
    const validSources = policy.evidenceFormat.source.values;
    if (!validSources.includes(evidence.source)) {
        errors.push({
            field: fieldName,
            type: 'invalid_evidence',
            message: `Invalid evidence source: ${evidence.source}. Must be one of: ${validSources.join(', ')}`,
            severity: 'error'
        });
    }

    // Check confidence
    const validConfidence = policy.evidenceFormat.confidence.values;
    if (!validConfidence.includes(evidence.confidence)) {
        errors.push({
            field: fieldName,
            type: 'invalid_evidence',
            message: `Invalid confidence level: ${evidence.confidence}. Must be one of: ${validConfidence.join(', ')}`,
            severity: 'error'
        });
    }

    return errors;
}

/**
 * Detect auto-question patterns
 */
function detectPattern(
    schema: Record<string, unknown>,
    properties: Record<string, any>,
    pattern: AutoQuestionPattern
): AutoGeneratedQuestion[] {
    const questions: AutoGeneratedQuestion[] = [];

    for (const [fieldName, fieldSchema] of Object.entries(properties)) {
        const match = matchesPattern(fieldName, fieldSchema, pattern);
        if (match) {
            questions.push({
                field: fieldName,
                question: generateQuestion(fieldName, fieldSchema, pattern),
                context: generateContext(fieldName, fieldSchema, pattern),
                reason: `auto_pattern: ${pattern.id}`,
                priority: pattern.action.priority
            });
        }
    }

    return questions;
}

/**
 * Check if field matches pattern
 */
function matchesPattern(
    fieldName: string,
    fieldSchema: any,
    pattern: AutoQuestionPattern
): boolean {
    switch (pattern.trigger.type) {
        case 'enum_count':
            const enumValues = fieldSchema.enum || fieldSchema.items?.enum;
            if (!enumValues) return false;
            const condition = pattern.trigger.condition || '';
            if (condition === '== 1') {
                return enumValues.length === 1;
            }
            return false;

        case 'keyword_detection':
            const keywords = pattern.trigger.keywords || [];
            const locations = pattern.trigger.location || ['enum', 'description', 'label'];

            for (const keyword of keywords) {
                if (locations.includes('enum')) {
                    const enumVals = fieldSchema.enum || fieldSchema.items?.enum || [];
                    if (enumVals.some((v: any) => String(v).includes(keyword))) {
                        return true;
                    }
                }
                if (locations.includes('description') && fieldSchema.description?.includes(keyword)) {
                    return true;
                }
                if (locations.includes('label') && fieldSchema['x-ui']?.label?.includes(keyword)) {
                    return true;
                }
            }
            return false;

        case 'field_analysis':
            if (pattern.trigger.condition === 'required field without default value') {
                // ðŸš¨ Check whitelist first
                const whitelist = (pattern as any).whitelist as string[] || [];
                if (whitelist.includes(fieldName)) {
                    return false;  // Skip whitelisted fields
                }

                // This would need access to parent required array
                return fieldSchema.default === undefined;
            }
            return false;

        default:
            return false;
    }
}

/**
 * Generate question from pattern
 */
function generateQuestion(
    fieldName: string,
    fieldSchema: any,
    pattern: AutoQuestionPattern
): string {
    return pattern.action.questionTemplate;
}

/**
 * Generate context for question
 */
function generateContext(
    fieldName: string,
    fieldSchema: any,
    pattern: AutoQuestionPattern
): string {
    if (pattern.trigger.type === 'enum_count') {
        const enumValues = fieldSchema.enum || fieldSchema.items?.enum || [];
        const firstValue = enumValues[0];
        return pattern.action.contextTemplate?.replace('{firstValue}', firstValue) ||
            `Only '${firstValue}' visible in image`;
    }

    if (pattern.trigger.type === 'keyword_detection') {
        const keywords = pattern.trigger.keywords || [];
        return `Keywords detected: ${keywords.join(', ')}`;
    }

    return pattern.trigger.context || '';
}

/**
 * Calculate evidence coverage percentage
 */
function calculateEvidenceCoverage(
    properties: Record<string, any>,
    policy: AccuracyPolicy
): number {
    let totalFields = 0;
    let fieldsWithEvidence = 0;

    for (const fieldSchema of Object.values(properties)) {
        if (shouldRequireEvidence(fieldSchema, policy)) {
            totalFields++;
            if (fieldSchema['x-evidence']) {
                fieldsWithEvidence++;
            }
        }
    }

    if (totalFields === 0) return 1.0;
    return fieldsWithEvidence / totalFields;
}

/**
 * Check quality gates
 */
function checkQualityGates(
    schema: Record<string, unknown>,
    policy: AccuracyPolicy,
    evidenceCoverage: number,
    questionCount: number
): ValidationError[] {
    const errors: ValidationError[] = [];

    // Check evidence completeness gate
    const evidenceGate = policy.qualityGates.evidenceCompleteness;
    if (evidenceGate.enabled && evidenceCoverage < (evidenceGate.minimumCoverage || 0.8)) {
        errors.push({
            field: '__schema__',
            type: 'quality_gate_failed',
            message: `Evidence coverage ${(evidenceCoverage * 100).toFixed(0)}% is below minimum ${((evidenceGate.minimumCoverage || 0.8) * 100)}%`,
            severity: 'error'
        });
    }

    // Check question quality gate
    const questionGate = policy.qualityGates.questionQuality;
    if (questionGate.enabled) {
        if (questionCount > (questionGate.maximumQuestions || 10)) {
            errors.push({
                field: '__schema__',
                type: 'quality_gate_failed',
                message: `Too many questions (${questionCount}). Maximum is ${questionGate.maximumQuestions || 10}`,
                severity: 'error'
            });
        }
    }

    return errors;
}
