# ============================================================================
# SHARED RULES - ê³µí†µ ì˜ë¯¸ ê·œì¹™ì˜ ë‹¨ì¼ ì§„ì‹¤ ì›ì²œ(SSOT)
# ============================================================================
# ì´ íŒŒì¼ì€ MCPì™€ UIê°€ ê³µí†µìœ¼ë¡œ ì°¸ì¡°í•˜ëŠ” ê·œì¹™ì…ë‹ˆë‹¤.
# ì¤‘ë³µì„ ë°©ì§€í•˜ê³  ì¼ê´€ì„±ì„ ìœ ì§€í•˜ê¸° ìœ„í•´ ì´ íŒŒì¼ë§Œ ìˆ˜ì •í•˜ì„¸ìš”.
#
# âš ï¸ SSOT ì›ì¹™ (v1.1 - ê²°ì •ë¡  ê°•í™”):
#   - ë²„ì „: versioning ì„¹ì…˜ë§Œ ì±…ì„
#   - ì„¹ì…˜/ê·¸ë£¹: schemaLogic.sectionRulesë§Œ ì±…ì„
#   - ë˜í¼: wrapperRegistryë§Œ ì±…ì„ (priority ì—†ìœ¼ë©´ defaultHandlers.wrapperPriorityDefault ì ìš©)
#   - ì»´í¬ë„ŒíŠ¸: componentRegistryë§Œ ì±…ì„
#   - ë§ˆì»¤: markerRegistry.idê°€ SSOT
#     â†’ íŠ¸ë¦¬ê±° ë¬¸ìì—´ì€ ëŸ°íƒ€ì„ì—ì„œ "has-marker:<MARKER_ID>" ìë™ ìƒì„±
#     â†’ triggerId í•„ë“œ ì—†ìŒ (ì¤‘ë³µ ì œê±°)
#   - ì¡°ê±´: êµ¬ì¡°í™”ëœ condition ê°ì²´ ì‚¬ìš© (ë¬¸ìì—´ í•˜ë“œì½”ë”© ê¸ˆì§€)
#     â†’ ì˜ˆ: { type: "has-marker", markerId: "MARKER_ENUM_BY_TYPE" }
#
# âš ï¸ ê²€ì¦ ê²½ê³„:
#   - shared.yaml ê²€ì¦ â†’ shared.meta.schema.json (CI)
#   - ì…ë ¥ ìŠ¤í‚¤ë§ˆ ê²€ì¦ â†’ unknownPolicy (ëŸ°íƒ€ì„)
#
# âš ï¸ ë©”íƒ€ìŠ¤í‚¤ë§ˆ: shared.meta.schema.json
# ============================================================================

# ============================================================================
# VERSIONING - ë²„ì „ ê´€ë¦¬ (ìœ ì¼í•œ ë²„ì „ SSOT)
# ============================================================================
versioning:
  rulesSpecVersion: "1.5.0"  # ğŸ”¥ SSOT 100ì : integrityRules + x-ui.sectionId
  inputSpec:
    schemaDraft: "draft-07"
    min: "1.0"
    max: "1.x"

# ============================================================================
# UNKNOWN POLICY - ì…ë ¥ ìŠ¤í‚¤ë§ˆ unknown í‚¤ ì²˜ë¦¬ (ëŸ°íƒ€ì„ìš©)
# ============================================================================
# âš ï¸ ì´ ì •ì±…ì€ Enhanced JSON Schema íŒŒì‹± ì‹œ ì ìš©ë¨
#    shared.yaml ìì²´ì˜ unknown í‚¤ëŠ” meta-schemaê°€ ê²€ì¦
unknownPolicy:
  transform:
    action: "passthrough"
    collectUnknown: true
  validate:
    unknownKey: "warn"
    unknownMarker: "warn"
    unsupportedStructure: "error"

# ============================================================================
# DEFAULT HANDLERS
# ============================================================================
defaultHandlers:
  typeInferenceFallback:
    type: "string"
    warn: true
  
  missingXui:
    label: "{key}"
    warn: true
  
  # ğŸ”¥ wrapperRegistry priority ì—†ì„ ë•Œ ì ìš©ë˜ëŠ” ê¸°ë³¸ê°’
  # ëŸ°íƒ€ì„ì—ì„œ ë°˜ë“œì‹œ ì´ ê°’ì„ ì‚¬ìš©í•´ì•¼ ê²°ì •ë¡  ë³´ì¥
  wrapperPriorityDefault: 0

# ============================================================================
# PRECEDENCE - ê·œì¹™ ìš°ì„ ìˆœìœ„ ì •ì˜ (ê²°ì •ë¡  ë³´ì¥)
# ============================================================================
# âš ï¸ ì ìš© ë²”ìœ„: ëª¨ë“  ë£° ì„¸íŠ¸ (wrapperRegistry, markerRegistry, sectionRules ë“±)
# âš ï¸ Merge ì „ëµ:
#   - ë™ì¼ í‚¤ â†’ ìƒìœ„ ìš°ì„ ìˆœìœ„ê°€ override (deep merge ì•„ë‹˜)
#   - ë¦¬ìŠ¤íŠ¸ â†’ ìƒìœ„ ìš°ì„ ìˆœìœ„ê°€ ì „ì²´ ëŒ€ì²´ (concat ì•„ë‹˜)
#   - ì—†ëŠ” í‚¤ â†’ í•˜ìœ„ ìš°ì„ ìˆœìœ„ì—ì„œ ìƒì†
precedence:
  order:
    - explicit    # ìŠ¤í‚¤ë§ˆ ë‚´ë¶€ x-schema-rules (ìµœìš°ì„ )
    - product     # ì œí’ˆë³„ ui.yaml, mcp.yaml
    - module      # ëª¨ë“ˆë³„ override (í–¥í›„)
    - shared      # ê³µí†µ shared.yaml
    - inference   # íƒ€ì… ì¶”ë¡  ê¸°ë³¸ê°’
  merge:
    sameKey: "override"      # ë™ì¼ í‚¤ â†’ ìƒìœ„ê°€ ë®ì–´ì”€
    list: "replace"          # ë¦¬ìŠ¤íŠ¸ â†’ ì „ì²´ ëŒ€ì²´
    missingKey: "inherit"    # ì—†ëŠ” í‚¤ â†’ í•˜ìœ„ì—ì„œ ìƒì†

# ============================================================================
# INTEGRITY RULES - ë ˆí¼ëŸ°ìŠ¤ ë¬´ê²°ì„± (SSOT)
# ============================================================================
# âš ï¸ ì´ ê·œì¹™ìœ¼ë¡œ ì°¸ì¡° ì¡´ì¬ ì—¬ë¶€ë¥¼ ëŸ°íƒ€ì„/CIì—ì„œ ê²€ì¦
integrityRules:
  # markerIdëŠ” ë°˜ë“œì‹œ markerRegistry.idì— ì¡´ì¬í•´ì•¼ í•¨
  requireMarkerIdInRegistry: true
  # condition.typeì€ ë°˜ë“œì‹œ conditionRegistry.typeì— ì¡´ì¬í•´ì•¼ í•¨
  requireConditionTypeInRegistry: true
  # ğŸ†• x-ui.groupIdëŠ” ë°˜ë“œì‹œ ui.yamlì˜ groupsì— ì¡´ì¬í•´ì•¼ í•¨ (optional validation)
  requireGroupIdInUiGroups: false  # Set to true when ui.yaml groups validation is implemented

# ============================================================================
# REGISTRIES
# ============================================================================

# ============================================================================
# MARKER REGISTRY - ìˆœìˆ˜ UI ë§ˆì»¤ë§Œ ë“±ë¡ (pureUI: true)
# ============================================================================
# âš ï¸ í•µì‹¬ ì›ì¹™: "x-* ì œê±°í•´ë„ ê²€ì¦ ë™ì‘ 100% ë™ì¼"
#   - ê²€ì¦ ë¡œì§ â†’ í‘œì¤€ JSON Schema í‚¤ì›Œë“œ (allOf if/then/required/enum)
#   - UI í‘œí˜„ â†’ x-* ë§ˆì»¤ (ì‚­ì œ ê°€ëŠ¥)
#
# âš ï¸ ê³¼ê±° ê²€ì¦ ë¡œì§ ë§ˆì»¤ (ë” ì´ìƒ ì‚¬ìš© ê¸ˆì§€):
#   - x-required-by-type â†’ allOf[].if.then.required ì‚¬ìš©
#   - x-enum-by-type â†’ allOf[].if.then.properties.*.enum ì‚¬ìš©
#   - x-node-count-by-type â†’ allOf[].if.then.properties.NODE.minItems/maxItems ì‚¬ìš©
#
# âš ï¸ ì¡°ê±´ë¶€ UI í‘œì‹œ ë§ˆì»¤ (ìˆœìˆ˜ UIìš©, ê²€ì¦ê³¼ ë¬´ê´€):
#   - x-required-when: ì¡°ê±´ ë§Œì¡± ì‹œ UIì—ì„œ í•„ìˆ˜ë¡œ í‘œì‹œ
#   - x-optional-when: ì¡°ê±´ ë§Œì¡± ì‹œ UIì—ì„œ ì„ íƒì ìœ¼ë¡œ í‘œì‹œ
# ============================================================================
markerRegistry:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # UI ë©”íƒ€ë°ì´í„° (label, groupId, hint)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: MARKER_UI
    key: "x-ui"
    description: "UI ë©”íƒ€ë°ì´í„° (label, groupId, hint)"
    pureUI: true  # ì‚­ì œí•´ë„ ê²€ì¦ ì˜í–¥ ì—†ìŒ
    schema:
      type: object
      properties:
        label: { type: string, description: "Field label (for UI display)" }
        groupId: { type: string, description: "Group ID (refers to x-ui.groups defined at object level)" }
        hint: { type: string, description: "Hint text" }
        groups: { type: array, description: "Group definitions (defined at object level)" }
        component: { type: string, description: "UI component type (e.g., RadioGroup)" }

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ì „ì†¡ ë©”íƒ€ë°ì´í„° (API ì •ë³´)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: MARKER_TRANSPORT
    key: "x-transport"
    description: "Transport ì •ë³´ (uri, method, bodyRoot)"
    pureUI: true


  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # TYPEë³„ Enum ë¼ë²¨ (ê²€ì¦ X, UI í‘œì‹œìš© ë¼ë²¨ë§Œ)
  # âš ï¸ ì‹¤ì œ enum ê°’ì€ allOf[].if.thenì—ì„œ ì •ì˜
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: MARKER_ENUM_LABELS_BY_TYPE
    key: "x-enum-labels-by-type"
    description: "TYPEë³„ enum ë¼ë²¨ (UI í‘œì‹œìš©, ê²€ì¦ ë¬´ê´€)"
    pureUI: true
    example: |
      x-enum-labels-by-type:
        TENSTR:
          "1": "Truss"
          "2": "Hook"
          "3": "Cable"
        COMPTR:
          "1": "Truss"
          "2": "Gap"


  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ì¡°ê±´ë¶€ í•„ë“œ í‘œì‹œ (UI ì „ìš© - ê²€ì¦ê³¼ ë¬´ê´€)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: MARKER_REQUIRED_WHEN
    key: "x-required-when"
    description: "ì¡°ê±´ ë§Œì¡± ì‹œ UIì—ì„œ í•„ìˆ˜ë¡œ í‘œì‹œ (ê²€ì¦ì€ allOf if/then ì‚¬ìš©)"
    pureUI: true
    schema:
      oneOf:
        - type: object
          description: "ë‹¨ì¼ ì¡°ê±´"
        - type: array
          items:
            type: object
            properties:
              condition: { type: object }
              hint: { type: string }
    example: |
      # ê°ì²´ í˜•ì‹ (ë‹¨ì¼ ì¡°ê±´)
      x-required-when: { "bSELFWT": true }
      
      # ë°°ì—´ í˜•ì‹ (ì—¬ëŸ¬ ì¡°ê±´ + íŒíŠ¸)
      x-required-when:
        - condition: { "TYPE": "WALL" }
          hint: "ë²½ì²´ íƒ€ì…ì—ì„œ í•„ìˆ˜"

  - id: MARKER_OPTIONAL_WHEN
    key: "x-optional-when"
    description: "ì¡°ê±´ ë§Œì¡± ì‹œ UIì—ì„œ ì„ íƒì ìœ¼ë¡œ í‘œì‹œ (ê²€ì¦ê³¼ ë¬´ê´€)"
    pureUI: true
    schema:
      oneOf:
        - type: object
          description: "ë‹¨ì¼ ì¡°ê±´"
        - type: array
          items:
            type: object
            properties:
              condition: { type: object }
              hint: { type: string }
    example: |
      # ê°ì²´ í˜•ì‹ (ë‹¨ì¼ ì¡°ê±´)
      x-optional-when: { "TYPE": "WALL" }
      
      # ë°°ì—´ í˜•ì‹ (ì—¬ëŸ¬ ì¡°ê±´ + íŒíŠ¸)
      x-optional-when:
        - condition: { "TYPE": "TENSTR" }
          hint: "ìŒìˆ˜ ì…ë ¥ ê¶Œì¥"
        - condition: { "TYPE": "COMPTR" }
          hint: "ì–‘ìˆ˜ ì…ë ¥ ê¶Œì¥"


# ============================================================================
# CONDITION REGISTRY - condition type taxonomy (ì „ì—­ SSOT)
# ============================================================================
# âš ï¸ ëª¨ë“  condition.typeì€ ì—¬ê¸° ë“±ë¡ëœ ê²ƒë§Œ ìœ íš¨ (schemaLogic/mcp/ui ê³µí†µ)
# âš ï¸ ëŸ°íƒ€ì„ì€ ì´ ë ˆì§€ìŠ¤íŠ¸ë¦¬ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê²€ì¦
conditionRegistry:
  - type: "has-marker"
    requiredParams: ["markerId"]
    description: "markerRegistry.id ì°¸ì¡°, í•´ë‹¹ ë§ˆì»¤ ì¡´ì¬ ì‹œ true"

  - type: "has-enum"
    requiredParams: []
    description: "ëª…ì‹œì  enum ë°°ì—´ ì¡´ì¬ ì‹œ true"

  - type: "has-oneOf-with-const"
    requiredParams: []
    description: "oneOf ë‚´ë¶€ì— const ì†ì„± ì¡´ì¬ ì‹œ true"

  - type: "has-minItems"
    requiredParams: []
    description: "minItems ì†ì„± ì¡´ì¬ ì‹œ true"

  - type: "has-maxItems"
    requiredParams: []
    description: "maxItems ì†ì„± ì¡´ì¬ ì‹œ true"

  - type: "has-type"
    requiredParams: []
    description: "type ì†ì„± ì¡´ì¬ ì‹œ true"

  - type: "has-explicit-groupId"
    requiredParams: []
    description: "x-ui.groupId is explicitly present (true if defined)"

  - type: "always"
    requiredParams: []
    description: "í•­ìƒ true (ê¸°ë³¸ fallback)"

  - type: "no-conditional-marker"
    requiredParams: []
    description: "x-required-when/x-optional-whenì´ ì—†ìœ¼ë©´ true"

  - type: "has-field-condition"
    requiredParams: ["field"]
    description: "íŠ¹ì • í•„ë“œ ì¡°ê±´ ì¡´ì¬ ì‹œ true"

  - type: "has-other-conditions"
    requiredParams: []
    description: "ê¸°íƒ€ ì¡°ê±´ ì¡´ì¬ ì‹œ true"

# ============================================================================
# GROUP SYSTEM - Inline group definitions (NOT centralized)
# ============================================================================
# âš ï¸ Groups are defined inline within each schema using x-ui.groups
# âš ï¸ sectionRegistry is DEPRECATED - use groupId instead
#
# Example:
#   x-ui:
#     groups:
#       - { id: "COMMON", title: "Common Keys" }
#       - { id: "TENSTR", title: "Tension Only" }
#   properties:
#     TYPE:
#       x-ui: { groupId: "COMMON" }

# 2. Wrapper Rules ë ˆì§€ìŠ¤íŠ¸ë¦¬ (SSOT)
# âš ï¸ ë§¤ì¹­ ì•Œê³ ë¦¬ì¦˜ (ê²°ì •ë¡  ë³´ì¥):
#   1. priority DESC ì •ë ¬ (ì—†ìœ¼ë©´ defaultHandlers.wrapperPriorityDefault ì ìš©)
#   2. ë™ë¥ ì´ë©´ ë¦¬ìŠ¤íŠ¸ ìˆœì„œ ìœ ì§€ (stable sort í•„ìˆ˜)
#   3. ì²« ë§¤ì¹­ rule ë°˜í™˜ (short-circuit)

# ğŸ”¥ v1.4: ì •ì±…ì„ YAMLë¡œ ì„ ì–¸ (SSOT)
wrapperRegistryPolicy:
  sort: "priorityDescStable"   # priority DESC + stable sort
  match: "first"               # ì²« ë§¤ì¹­ ë°˜í™˜

wrapperRegistry:
  - id: WRAP_DB
    pattern: "^/db/"
    wrapper: "Assign"
    priority: 10

  - id: WRAP_POST
    pattern: "^/post/"
    wrapper: "Argument"
    priority: 10

  - id: WRAP_DOC
    pattern: "^/doc/"
    wrapper: "Argument"
    priority: 10

  - id: WRAP_DESIGN
    pattern: "^/design/"
    wrapper: "Assign"
    priority: 10
    description: "Design DB APIs use Assign wrapper"

  - id: WRAP_DEFAULT
    pattern: ".*"
    wrapper: null
    priority: -1

# 3. íƒ€ì… ì ‘ë‘ì‚¬ ì¶”ë¡  ë ˆì§€ìŠ¤íŠ¸ë¦¬
typeInferenceRegistry:
  - id: TYPE_INT
    prefix: "i"
    type: "integer"
    example: "iTENDON_TYPE"

  - id: TYPE_BOOL
    prefix: "b"
    type: "boolean"
    example: "bCRACK_CHECK"

  - id: TYPE_NUM
    prefix: "d"
    type: "number"
    example: "dEXPOSURE_VALUE"

  - id: TYPE_STR
    prefix: "s"
    type: "string"
    example: "sCODE_NAME"

# 4. í•„ë“œ íƒ€ì… â†’ UI ì»´í¬ë„ŒíŠ¸ ë ˆì§€ìŠ¤íŠ¸ë¦¬ (SSOT)
componentRegistry:
  string:
    component: "Input"
    props: { type: "text" }

  number:
    component: "Input"
    props: { type: "number" }

  integer:
    component: "Input"
    props: { type: "number" }

  boolean:
    component: "Checkbox"
    props: {}

  array:
    component: "Textarea"
    props: { placeholder: "Enter as JSON array, e.g., [1, 2, 3]" }

  object:
    component: "Textarea"
    props: { placeholder: "Enter as JSON object" }

  enum:
    component: "Select"
    props: {}

# ============================================================================
# NAMING POLICY
# ============================================================================
naming:
  yamlKeyPolicy:
    min: 3
    max: 20
    style: "camelCase"
  
  fieldNamePolicy:
    # ğŸ”¥ v1.4: íŒŒìƒ ê·œì¹™ì„ YAMLë¡œ ì„ ì–¸ (SSOT)
    prefixSource: "typeInferenceRegistry"  # allowedPrefixes = typeInferenceRegistry.map(prefix)
    allowUppercase: true
    maxLength: 30
  
  conflict:
    strategy: "suffix"
    format: "{key}_{n}"

# ============================================================================
# OUTPUT META - ì¶œë ¥ ë©”íƒ€ë°ì´í„° í…œí”Œë¦¿
# ============================================================================
# âš ï¸ source ê²½ë¡œ ê·œì¹™:
#   - versioning.* : shared.yamlì—ì„œ ì§ì ‘ ì½ìŒ
#   - _computed.*  : ëŸ°íƒ€ì„ì—ì„œ ê³„ì‚° (sourceHash, outputHash ë“±)
# âš ï¸ ì—ëŸ¬ ì •ì±…:
#   - required: true â†’ í•´ì„ ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ (í”„ë¡œì„¸ìŠ¤ ì¤‘ë‹¨)
#   - required: false + onMissing: warn â†’ ê²½ê³  + null
#   - required: false + onMissing: null â†’ ì¡°ìš©íˆ null
outputMeta:
  # ê¸°ë³¸ ì—ëŸ¬ ì •ì±… (ê°œë³„ í•„ë“œì—ì„œ override ê°€ëŠ¥)
  defaults:
    required: false
    onMissing: "warn"  # "warn" | "error" | "null"
  fields:
    - alias: "rulesSpecVersion"
      source: "versioning.rulesSpecVersion"
      required: true  # í•„ìˆ˜ - ì—†ìœ¼ë©´ ì—ëŸ¬
    - alias: "sourceHash"
      source: "_computed.sourceHash"
    - alias: "outputHash"
      source: "_computed.outputHash"
    - alias: "generatedAt"
      source: "_computed.generatedAt"
      required: true  # í•„ìˆ˜
    - alias: "appliedRuleIds"
      source: "_computed.appliedRuleIds"
    - alias: "warnings"
      source: "_computed.warnings"
      onMissing: "null"  # ê²½ê³  ì—†ì´ null
    - alias: "unknownKeys"
      source: "_computed.unknownKeys"
      onMissing: "null"  # ê²½ê³  ì—†ì´ null

# ============================================================================
# DIAGNOSTICS - ì§„ë‹¨ ì½”ë“œ ì²´ê³„
# ============================================================================
diagnostics:
  errors:
    - code: "ENUM_INVALID_FORMAT"
      level: "error"
      message: "ì •ìˆ˜ enumì€ oneOf í˜•ì‹ í•„ìˆ˜"
      fix: "auto-convert"

    - code: "PREFIX_TYPE_MISMATCH"
      level: "error"
      message: "ì ‘ë‘ì‚¬ì™€ íƒ€ì… ë¶ˆì¼ì¹˜: {field}ëŠ” {expected} íƒ€ì…ì´ì–´ì•¼ í•¨"

    - code: "UNSUPPORTED_STRUCTURE"
      level: "error"
      message: "ì§€ì›í•˜ì§€ ì•ŠëŠ” ìŠ¤í‚¤ë§ˆ êµ¬ì¡°: {structure}"

    - code: "INVALID_FIELD_NAME_POLICY"
      level: "error"
      message: "í•„ë“œëª… ì •ì±… ìœ„ë°˜: {field}"

    - code: "INVALID_YAML_KEY_POLICY"
      level: "error"
      message: "YAML í‚¤ ì •ì±… ìœ„ë°˜: {key}"

    - code: "OUTPUT_META_SOURCE_NOT_FOUND"
      level: "error"
      message: "outputMeta source ê²½ë¡œ í•´ì„ ì‹¤íŒ¨: {source}"

  warnings:
    - code: "MISSING_XUI_LABEL"
      level: "warn"
      message: "x-ui.label ëˆ„ë½: {field}"
      fix: "generate-from-key"

    - code: "MISSING_XUI_GROUP"
      level: "warn"
      message: "x-ui.group ëˆ„ë½: {field}"

    - code: "UNKNOWN_KEY"
      level: "warn"
      message: "ì•Œ ìˆ˜ ì—†ëŠ” í‚¤: {key}"

    - code: "UNKNOWN_MARKER"
      level: "warn"
      message: "ì•Œ ìˆ˜ ì—†ëŠ” ë§ˆì»¤: {marker}"

# ============================================================================
# SCHEMA LOGIC - ìŠ¤í‚¤ë§ˆ ì²˜ë¦¬ ë¡œì§ (ë„¤ì„ìŠ¤í˜ì´ìŠ¤)
# ============================================================================
schemaLogic:
  schemaStructurePatterns:
    # ğŸ”¥ Pattern 1a: Assign + additionalProperties
    # ì´ íŒ¨í„´ì€ Map ê¸°ë°˜ ì—”í‹°í‹° ì»¬ë ‰ì…˜ì„ ì²˜ë¦¬
    - name: "Unwrap Wrapper with AdditionalProperties"
      description: "Assign/Argument ë˜í¼ì˜ additionalPropertiesì—ì„œ ì—”í‹°í‹° ìŠ¤í‚¤ë§ˆ ì¶”ì¶œ"
      enabled: true
      priority: 0  # ê°€ì¥ ë¨¼ì € ì²´í¬
      detect:
        - path: "type"
          value: "object"
        - path: "properties.Assign.additionalProperties"
          exists: true
        - path: "properties.Assign.additionalProperties.type"
          value: "object"
      transform:
        action: "unwrap-wrapper-with-additionalProperties"
        
    # ğŸ”¥ Pattern 1b: Argument + additionalProperties
    - name: "Unwrap Argument Wrapper with AdditionalProperties"
      description: "Argument ë˜í¼ì˜ additionalPropertiesì—ì„œ ì—”í‹°í‹° ìŠ¤í‚¤ë§ˆ ì¶”ì¶œ"
      enabled: true
      priority: 0
      detect:
        - path: "type"
          value: "object"
        - path: "properties.Argument.additionalProperties"
          exists: true
        - path: "properties.Argument.additionalProperties.type"
          value: "object"
      transform:
        action: "unwrap-wrapper-with-additionalProperties"

    # ğŸ”¥ Pattern 1c: Assign + patternProperties (NEW)
    # patternProperties["^[0-9]+$"] íŒ¨í„´ì„ ì‚¬ìš©í•˜ëŠ” ìŠ¤í‚¤ë§ˆ ì§€ì›
    - name: "Unwrap Assign Wrapper with PatternProperties"
      description: "Assign ë˜í¼ì˜ patternPropertiesì—ì„œ ì—”í‹°í‹° ìŠ¤í‚¤ë§ˆ ì¶”ì¶œ"
      enabled: true
      priority: 0
      detect:
        - path: "type"
          value: "object"
        - path: "properties.Assign.patternProperties"
          exists: true
      transform:
        action: "unwrap-wrapper-with-additionalProperties"

    # ğŸ”¥ Pattern 1d: Argument + patternProperties (NEW)
    - name: "Unwrap Argument Wrapper with PatternProperties"
      description: "Argument ë˜í¼ì˜ patternPropertiesì—ì„œ ì—”í‹°í‹° ìŠ¤í‚¤ë§ˆ ì¶”ì¶œ"
      enabled: true
      priority: 0
      detect:
        - path: "type"
          value: "object"
        - path: "properties.Argument.patternProperties"
          exists: true
      transform:
        action: "unwrap-wrapper-with-additionalProperties"

    # ğŸ”¥ Pattern 1e: Argument with direct properties (Table API)
    # wrapWithSimpleObjectë¡œ ìƒì„±ëœ Table ìŠ¤í‚¤ë§ˆ íŒ¨í„´
    # additionalPropertiesê°€ falseì´ê±°ë‚˜ ì—†ëŠ” ê²½ìš° (Map íŒ¨í„´ì´ ì•„ë‹Œ ê²½ìš°)
    - name: "Unwrap Argument Wrapper with Properties"
      description: "Argument ë˜í¼ì˜ propertiesì—ì„œ Table ìŠ¤í‚¤ë§ˆ ì¶”ì¶œ (Map íŒ¨í„´ ì•„ë‹˜)"
      enabled: true
      priority: 0
      detect:
        - path: "type"
          value: "object"
        - path: "properties.Argument.type"
          value: "object"
        - path: "properties.Argument.properties"
          exists: true
        # additionalPropertiesê°€ object íƒ€ì…ì´ ì•„ë‹Œì§€ í™•ì¸ (false ë˜ëŠ” ì—†ìŒ)
        - path: "properties.Argument.additionalProperties.type"
          exists: false
        # patternPropertiesê°€ ì—†ëŠ”ì§€ í™•ì¸
        - path: "properties.Argument.patternProperties"
          exists: false
      transform:
        action: "unwrap-wrapper-with-additionalProperties"

    # Pattern 2: ê¸°ì¡´ unwrap-root-key (ë ˆê±°ì‹œ)
    - name: "Unwrap Root Wrapper Key"
      description: "ë£¨íŠ¸ ë˜í¼ í‚¤ë¥¼ ì œê±°í•˜ê³  ë‚´ë¶€ ìŠ¤í‚¤ë§ˆë¥¼ ëŒì–´ì˜¬ë¦¼"
      enabled: true
      priority: 1
      detect:
        - path: "$schema"
          exists: false
        - path: "type"
          exists: false
      transform:
        action: "unwrap-root-key"
        extractTitle: true
        preserveMetadata: ["description", "x-ui", "x-transport"]

  platformSkeleton:
    entityCollection:
      description: "Platform Standard Collection Map"
      type: "object"
      patternProperties:
        pattern: "^[0-9]+$"
        description: "Entity ID (numeric)"
        ref: "#/$defs/entity"
      additionalProperties: false
      minProperties: 0
    defaultBodyRoot: "Assign"
    alternativeBodyRoots:
      - "Argument"
      - "Assign"
    rootStructure:
      type: "object"
      additionalProperties: false

  # âš ï¸ NOTE: sectionRules deprecated - using x-ui.groupId instead
  # sectionRegistry does not exist, so sectionId is not used
  sectionRules: []
  sectionOrder: []

  typeLabels: {}

  # Enum íŒì • ê·œì¹™
  # âš ï¸ êµ¬ì¡°í™”ëœ condition ì‚¬ìš© (ë¬¸ìì—´ í•˜ë“œì½”ë”© ê¸ˆì§€)
  #    markerRegistry.idë¥¼ ì§ì ‘ ì°¸ì¡°
  enumDetectionRules:
    - id: ENUM_EXPLICIT
      condition:
        type: "has-enum"
      description: "ëª…ì‹œì  enum ë°°ì—´ì´ ìˆìœ¼ë©´ enum"

    - id: ENUM_ONEOF_CONST
      condition:
        type: "has-oneOf-with-const"
      description: "oneOf ë‚´ë¶€ì— constê°€ ìˆìœ¼ë©´ enum"

    # âš ï¸ NOTE: MARKER_ENUM_BY_TYPE removed - not defined in markerRegistry
    # Use MARKER_ENUM_LABELS_BY_TYPE if needed for type-specific enum labels

  visibilityRules:
    - name: "No Conditional Marker"
      description: "x-required-when/x-optional-whenì´ ì—†ìœ¼ë©´ í•­ìƒ í‘œì‹œ"
      condition:
        type: "no-conditional-marker"
      result: true
    - name: "TYPE Condition"
      description: "TYPE í•„ë“œ ì¡°ê±´ í™•ì¸"
      condition:
        type: "has-field-condition"
        field: "TYPE"
      evaluation:
        operator: "in"
        field: "TYPE"
    - name: "Other Field Conditions"
      description: "ë‹¤ë¥¸ í•„ë“œ ì¡°ê±´ í™•ì¸"
      condition:
        type: "has-other-conditions"
      evaluation:
        operator: "all-match"

  requiredCalculationRules:
    priority:
      - "base-required"
      - "conditional-required"
      - "visibility-check"
    baseRequired:
      description: "ìµœìƒìœ„ required ë°°ì—´ì— ìˆìœ¼ë©´ ëª¨ë“  TYPEì—ì„œ required"
      status: "required"
    conditionalRequired:
      description: "allOf ì¡°ê±´ì— ë§¤ì¹­ë˜ë©´ í•´ë‹¹ TYPEì—ì„œ required"
      status: "required"
    notVisible:
      description: "ì¡°ê±´ë¶€ ë§ˆì»¤(x-required-when/x-optional-when) ì¡°ê±´ìœ¼ë¡œ ë³´ì´ì§€ ì•Šìœ¼ë©´ n/a"
      status: "n/a"
    default:
      description: "ê¸°ë³¸ê°’"
      status: "optional"

  # ê²€ì¦ ë ˆì´ì–´ ê²°ì • ê·œì¹™
  # âš ï¸ êµ¬ì¡°í™”ëœ condition ì‚¬ìš©
  validationLayerRules:
    STD:
      description: "Standard JSON Schema validation"
      triggers:
        - condition:
            type: "has-enum"
        - condition:
            type: "has-minItems"
        - condition:
            type: "has-maxItems"
        - condition:
            type: "has-type"
    # âš ï¸ NOTE: APP validation triggers removed
    # MARKER_ENUM_BY_TYPE, MARKER_NODE_COUNT, MARKER_VALUE_CONSTRAINT not defined in markerRegistry

  descriptionBuildingRules:
    order:
      - label
      - enum-values
      - enum-by-type
      - value-constraints
      - node-count-by-type
      - hint
    templates:
      label: "<strong>{label}</strong>"
      enum-values:
        header: "<strong>Enum Values:</strong>"
        item: "<li><code>{value}</code> - {label}</li>"
        wrapper: "<ul>{items}</ul>"
      enum-by-type:
        header: "<strong>Enum Values by Type:</strong>"
        type-header: "<p><em>{type}:</em></p>"
        item: "<li><code>{value}</code> - {label}</li>"
        wrapper: "<ul>{items}</ul>"
      value-constraints:
        header: "<strong>Value Constraints:</strong>"
        item: "<li><em>{type}:</em> {constraint}</li>"
        wrapper: "<ul>{items}</ul>"
      node-count-by-type:
        header: "<strong>Node Count by Type:</strong>"
        item: "<li><em>{type}:</em> {count} nodes</li>"
        wrapper: "<ul>{items}</ul>"
      hint: '<p class="hint">{hint}</p>'

# ============================================================================
# SCHEMA STRUCTURE PATTERNS - ìŠ¤í‚¤ë§ˆ êµ¬ì¡° ê°ì§€ ë° ë³€í™˜ ê·œì¹™
# ============================================================================
# âš ï¸ ì´ íŒ¨í„´ë“¤ì€ schemaCompilerê°€ ìŠ¤í‚¤ë§ˆë¥¼ íŒŒì‹±í•  ë•Œ ì‚¬ìš©ë¨
#   - ë˜í¼ ê°ì§€: Assign, Argument ë“±ì˜ ë˜í¼ í‚¤
#   - ì—”í‹°í‹° ì¶”ì¶œ: additionalProperties ë‚´ë¶€ ìŠ¤í‚¤ë§ˆë¥¼ ì¶”ì¶œ
#   - allOf ì²˜ë¦¬: if/then ì¡°ê±´ë¶€ ê²€ì¦ ë¡œì§
# ============================================================================
schemaStructurePatterns:
  # ğŸ”¥ ë˜í¼ í‚¤ ì •ì˜ (API body-root)
  wrapperKeys:
    - key: "Assign"
      description: "DB PUT/POST - Map ê¸°ë°˜ ë‹¤ì¤‘ ì—”í‹°í‹°"
      example: '{ "Assign": { "1": {...}, "2": {...} } }'
    - key: "Argument"
      description: "Function Call - ë‹¨ì¼ ì¸ì ê°ì²´"
      example: '{ "Argument": {...} }'

  # ğŸ”¥ ì—”í‹°í‹° ì»¬ë ‰ì…˜ íŒ¨í„´ (Assign/Argument ë‚´ë¶€ êµ¬ì¡°)
  entityCollectionPattern:
    # íŒ¨í„´ ê°ì§€ ì¡°ê±´ (ëª¨ë‘ ë§Œì¡±í•´ì•¼ í•¨)
    detect:
      - path: "properties.*.type"
        value: "object"
      - path: "properties.*.additionalProperties"
        exists: true
    # ì—”í‹°í‹° ì¶”ì¶œ ìœ„ì¹˜
    entityPath: "properties.{wrapperKey}.additionalProperties"
    # ì—”í‹°í‹° ìŠ¤í‚¤ë§ˆì—ì„œ í•„ë“œ ì¶”ì¶œ
    fieldExtractionRules:
      properties: "properties"
      required: "required"
      allOf: "allOf"
      xUi: "x-ui"

  # ğŸ”¥ allOf if/then íŒ¨í„´ - ì¡°ê±´ë¶€ ê²€ì¦ ë¡œì§
  conditionalValidation:
    # allOf ë°°ì—´ì—ì„œ if/then ë¸”ë¡ ì¶”ì¶œ
    pattern: "allOf[*].{if,then}"
    # if ë¸”ë¡ êµ¬ì¡°
    ifStructure:
      properties: "properties"     # { TYPE: { const: "BEAM" } }
      required: "required"         # ["TYPE"]
    # then ë¸”ë¡ êµ¬ì¡°
    thenStructure:
      required: "required"         # ì¡°ê±´ë¶€ required í•„ë“œë“¤
      properties: "properties"     # ì¡°ê±´ë¶€ enum, minItems, maxItems ë“±

  # ğŸ”¥ ì¡°ê±´ë¶€ required ë§¤í•‘ ìƒì„± ê·œì¹™
  conditionalRequiredMapping:
    # allOf[].if.properties.TYPE.const â†’ conditionValue
    # allOf[].then.required â†’ requiredFields
    # ê²°ê³¼: { "BEAM": ["SECT"], "TENSTR": ["SECT", "STYPE", "NON_LEN"], ... }
    conditionField: "TYPE"  # ê¸°ë³¸ ì¡°ê±´ í•„ë“œ (ëŒ€ë¶€ë¶„ TYPE)
    multiCondition: true    # TYPE + STYPE ê°™ì€ ë³µí•© ì¡°ê±´ ì§€ì›

  # ğŸ”¥ ì¡°ê±´ë¶€ enum ë§¤í•‘ ìƒì„± ê·œì¹™
  conditionalEnumMapping:
    # allOf[].if.properties.TYPE.const â†’ conditionValue
    # allOf[].then.properties.STYPE.enum â†’ enumValues
    # ê²°ê³¼: { "TENSTR": [1,2,3], "COMPTR": [1,2], ... }
    extractFrom: "allOf[*].then.properties.*.enum"

  # ğŸ”¥ ì¡°ê±´ë¶€ NODE ê°œìˆ˜ ë§¤í•‘ ìƒì„± ê·œì¹™
  conditionalNodeCountMapping:
    # allOf[].if.properties.TYPE.const â†’ conditionValue
    # allOf[].then.properties.NODE.minItems/maxItems â†’ nodeCount
    # ê²°ê³¼: { "BEAM": { min: 2, max: 2 }, "PLATE": { min: 3, max: 4 }, ... }
    extractFrom: "allOf[*].then.properties.NODE.{minItems,maxItems}"

  # ğŸ”¥ x-uiRules.visibleWhen â†’ x-optional-when ë³€í™˜ ê·œì¹™
  # schemaCompilerì—ì„œ ìë™ìœ¼ë¡œ x-optional-whenìœ¼ë¡œ ë³€í™˜ë¨
  uiVisibilityRules:
    markerKey: "x-uiRules"
    visibleWhenPath: "visibleWhen"
    # âœ… ìë™ ë³€í™˜: x-uiRules.visibleWhen â†’ x-optional-when
    autoConvertTo: "x-optional-when"
    # ì¡°ê±´ í•„ë“œ (TYPE, STYPE ë“±)
    supportedConditionFields:
      - "TYPE"
      - "STYPE"
      - "iMETHOD"
      - "bSELFWEIGHT"
    # ì¡°ê±´ í˜•ì‹ ì§€ì›
    conditionFormats:
      single: "{ TYPE: 'TENSTR' }"           # ë‹¨ì¼ ê°’
      multi: "{ TYPE: 'TENSTR', STYPE: 3 }"  # ë³µí•© ì¡°ê±´

# ============================================================================
# TABLE SCHEMA REGISTRY - POST Table API ê³µí†µ íƒ€ì… ì •ì˜ (MCP SSOT)
# ============================================================================
# âš ï¸ MCPê°€ Table ìŠ¤í‚¤ë§ˆ ìƒì„± ì‹œ ì´ ë ˆì§€ìŠ¤íŠ¸ë¦¬ë¥¼ ì°¸ì¡°í•˜ì—¬ ì¼ê´€ëœ êµ¬ì¡° ìœ ì§€
# UI ìŠ¤í¬ë¦°ìƒ· â†’ ìŠ¤í‚¤ë§ˆ ìƒì„± ì‹œ ê³µí†µ í•„ë“œëŠ” ì—¬ê¸°ì„œ ê°€ì ¸ì˜´
# 
# ì°¸ì¡° ë¶„ì„ ê¸°ë°˜:
#   - 013_Displacements_-_Analysis_Result_Table.html
#   - 024_Plate_Force_Local_-_Analysis_Result_Table.html
#   - 049_Elastic_Link_-_Analysis_Result_Table.html
#   - 019_Beam_Force_-_Analysis_Result_Table_enhanced.json
# ============================================================================
tableSchemaRegistry:
  version: "1.0.0"
  description: "POST Table API ê³µí†µ ìŠ¤í‚¤ë§ˆ ì •ì˜"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ë˜í¼ êµ¬ì¡° (ëª¨ë“  Table ìŠ¤í‚¤ë§ˆ ê³µí†µ)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  wrapper:
    root: "TABLE"
    bodyRoot: "Argument"
    structure: |
      {
        "TABLE": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "{schemaTitle}",
          "type": "object",
          "properties": {
            "Argument": { ... }
          }
        }
      }

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ê³µí†µ í•„ë“œ ì •ì˜ (COMMON FIELDS) - ëŒ€ë¶€ë¶„ì˜ Table APIì— ê³µí†µ
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  commonFields:
    TABLE_NAME:
      type: "string"
      description: "Response Table Title"
      default: ""
      required: false
      x-ui:
        label: "Table Name"
        hint: "Output table title in response"

    TABLE_TYPE:
      type: "string"
      description: "Result Table Type"
      required: true
      note: "enum values are table-specific (e.g., DISPLACEMENTG, BEAMFORCE)"
      x-ui:
        label: "Table Type"

    EXPORT_PATH:
      type: "string"
      description: "Result Table Save Path"
      required: false
      x-ui:
        label: "Export Path"
        hint: "Optional: Save results to file path"

    UNIT:
      type: "object"
      description: "Response Unit Setting"
      required: false
      properties:
        FORCE:
          type: "string"
          description: "Force unit"
        DIST:
          type: "string"
          description: "Length/Distance unit"
        HEAT:
          type: "string"
          description: "Heat unit"
        TEMP:
          type: "string"
          description: "Temperature unit"
      x-ui:
        label: "Unit Settings"

    STYLES:
      type: "object"
      description: "Response Number Format"
      required: false
      properties:
        FORMAT:
          type: "string"
          description: "Number format"
          enum: ["Default", "Fixed", "Scientific", "General"]
        PLACE:
          type: "integer"
          description: "Digit place"
          minimum: 0
          maximum: 15
      x-ui:
        label: "Number Format"

    COMPONENTS:
      type: "array"
      description: "Components of Result Table"
      items:
        type: "string"
      required: false
      note: "enum values are table-specific"
      x-ui:
        label: "Components"

    # NODE_ELEMS: ì„¸ ê°€ì§€ ë°©ì‹ ì¤‘ í•˜ë‚˜ ì‚¬ìš© (KEYS, TO, STRUCTURE_GROUP_NAME)
    NODE_ELEMS:
      type: "object"
      description: "Node/Element No. Input"
      required: false
      properties:
        KEYS:
          type: "array"
          description: "Specify Each ID"
          items:
            type: "integer"
        TO:
          type: "string"
          description: "Specify ID Range (e.g., '1to160')"
        STRUCTURE_GROUP_NAME:
          type: "string"
          description: "Specify Structure Group Name"
      x-ui:
        label: "Node/Element Selection"
        hint: "Use only ONE of the three methods: KEYS, TO, or STRUCTURE_GROUP_NAME"

    LOAD_CASE_NAMES:
      type: "array"
      description: "Load Case/Combination Names"
      items:
        type: "string"
      required: false
      note: "Format: NAME(ST), NAME(CS), NAME(RS), NAME(CB) etc."
      x-ui:
        label: "Load Cases"
        hint: "Static Load or Load Combination names"

    OPT_CS:
      type: "boolean"
      description: "Activation - Construction Stage Step"
      default: false
      required: false
      x-ui:
        label: "Construction Stage"

    STAGE_STEP:
      type: "array"
      description: "Stage Step Names"
      items:
        type: "string"
      required: false
      x-ui:
        label: "Stage Steps"
      x-optional-when:
        OPT_CS: true

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # í…Œì´ë¸”ë³„ ê³ ìœ  í•„ë“œ (TABLE-SPECIFIC FIELDS)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  tableSpecificFields:
    # â”€â”€â”€ Displacement ì „ìš© â”€â”€â”€
    DISP_OPT:
      type: "string"
      description: "Displacement Option"
      enum: ["Accumulative", "Current", "Real"]
      tables: ["DISPLACEMENTG", "DISPLACEMENTL"]
      x-ui:
        label: "Displacement Option"

    # â”€â”€â”€ Beam Force ì „ìš© â”€â”€â”€
    PARTS:
      type: "array"
      description: "Element Part Number"
      items:
        type: "string"
        enum: ["All", "PartI", "Part1/4", "Part2/4", "Part3/4", "PartJ"]
      default: ["All"]
      tables: ["BEAMFORCE", "BEAMFORCEVBM", "BEAMSTRESS"]
      x-ui:
        component: "CheckboxGroup"
        label: "Element Parts"

    BEAM_ITEM_TO_DISPLAY:
      type: "array"
      description: "Select Component to Display (Beam)"
      items:
        type: "string"
        enum: ["Force-x", "Shear-y", "Shear-z", "Moment-y", "Moment-z", "Torsion"]
      tables: ["BEAMFORCE", "BEAMFORCEVBM"]
      x-ui:
        label: "Beam Components to Display"

    # â”€â”€â”€ Plate Force ì „ìš© â”€â”€â”€
    AVERAGE_NODAL_RESULT:
      type: "boolean"
      description: "Average Nodal Result Option"
      default: false
      tables: ["PLATEFORCEL", "PLATEFORCEG", "PLATESTRESS"]
      x-ui:
        label: "Average Nodal Result"

    # â”€â”€â”€ Elastic Link ì „ìš© â”€â”€â”€
    LINK_ITEM_TO_DISPLAY:
      type: "array"
      description: "Select Component to Display (Elastic Link)"
      items:
        type: "string"
        enum: ["Axial", "Shear-y", "Shear-z", "Moment-x", "Moment-y", "Moment-z"]
      tables: ["ELASTICLINK", "ELASTICLINKVBM"]
      x-ui:
        label: "Link Components to Display"

    # â”€â”€â”€ Element Type ì„ íƒ (ì¼ë¶€ í…Œì´ë¸”) â”€â”€â”€
    SELECT_TYPE:
      type: "string"
      description: "Element Type Selection"
      enum: ["TRUSS", "BEAM", "PLANE STRESS", "PLATE", "PLANE STRAIN", "AXISYMMETRIC", "SOLID", "TENS-TRUSS", "COMP-TRUSS"]
      tables: ["result-tables"]
      x-ui:
        label: "Select Type"

    # â”€â”€â”€ Construction Stage Stress ì „ìš© (STRESSCS) â”€â”€â”€
    COMP_TENS:
      type: "array"
      description: "Compression/Tension Selection"
      items:
        type: "string"
        enum: ["All", "Compression", "Tension"]
      default: ["All"]
      tables: ["STRESSCS"]
      x-ui:
        component: "CheckboxGroup"
        label: "Comp./Tens."

    GIRDER_SLAB:
      type: "string"
      description: "Girder or Slab Selection"
      default: "GIRDER"
      oneOf:
        - title: "Girder"
          const: "GIRDER"
        - title: "Slab"
          const: "SLAB"
      tables: ["STRESSCS"]
      x-ui:
        component: "RadioGroup"
        label: "Girder/Slab"

    PARTS_CS:
      type: "array"
      description: "Part Number Selection (Construction Stage)"
      items:
        type: "string"
        enum: ["All", "Part_i", "Part_j"]
      default: ["All"]
      tables: ["STRESSCS"]
      x-ui:
        component: "CheckboxGroup"
        label: "Part Number"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # MCP ìƒì„± ê·œì¹™ (AIê°€ ìŠ¤í‚¤ë§ˆ ìƒì„± ì‹œ ì°¸ì¡°)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  generationRules:
    # í•­ìƒ í¬í•¨í•´ì•¼ í•  ê³µí†µ í•„ë“œ
    alwaysInclude:
      - TABLE_NAME
      - TABLE_TYPE
      - EXPORT_PATH
      - UNIT
      - STYLES
      - COMPONENTS

    # ëŒ€ë¶€ë¶„ í¬í•¨í•´ì•¼ í•  í•„ë“œ
    usuallyInclude:
      - NODE_ELEMS
      - LOAD_CASE_NAMES

    # ì¡°ê±´ë¶€ í¬í•¨ í•„ë“œ
    conditionalInclude:
      - field: OPT_CS
        condition: "Construction Stage ê¸°ëŠ¥ ìˆëŠ” ê²½ìš°"
      - field: STAGE_STEP
        condition: "OPT_CSê°€ trueì¼ ë•Œ"
      - field: AVERAGE_NODAL_RESULT
        condition: "Plate/Solid íƒ€ì… ê²°ê³¼ í…Œì´ë¸”"

    # UI ì „ìš© ìš”ì†Œ (ìŠ¤í‚¤ë§ˆì— í¬í•¨í•˜ì§€ ì•ŠìŒ)
    excludeFromSchema:
      - "All button"
      - "None button"
      - "Inverse button"
      - "Prev button"
      - "Add button"
      - "Delete button"
      - "Replace button"
      - "Intersect button"
      - "OK button"
      - "Cancel button"
      - "Help button"
      - "Close button"
      - "Select Type dropdown"  # ğŸš¨ UI ì „ìš© - ìŠ¤í‚¤ë§ˆì— í¬í•¨ ê¸ˆì§€
      - "Element Type dropdown"  # ğŸš¨ UI ì „ìš© - ìŠ¤í‚¤ë§ˆì— í¬í•¨ ê¸ˆì§€

    # NODE_ELEMSëŠ” ë°˜ë“œì‹œ oneOf íŒ¨í„´ ì‚¬ìš©
    nodeElemsRule: |
      NODE_ELEMS MUST always use oneOf pattern with 3 methods:
      1. KEYS (array of integers) - Specify each node/element ID
      2. TO (string, e.g., "1to5") - Specify ID range
      3. STRUCTURE_GROUP_NAME (string) - Specify structure group name

    # ğŸš¨ ë¶ˆí™•ì‹¤í•  ë•Œ questions íŒŒë¼ë¯¸í„° ì‚¬ìš©
    askQuestions:
      - "TABLE_TYPE enum ì˜µì…˜ì´ 1ê°œë§Œ ë³´ì´ë©´ ì „ì²´ ëª©ë¡ ì§ˆë¬¸"
      - "COMPONENTSì˜ enum ê°’ì´ ë¶ˆëª…í™•í•˜ë©´ ì§ˆë¬¸"
      - "í…Œì´ë¸”ë³„ íŠ¹ìˆ˜ í•„ë“œ ì¡´ì¬ ì—¬ë¶€ ë¶ˆí™•ì‹¤í•˜ë©´ ì§ˆë¬¸"

