# ============================================================================
# SHARED RULES - ê³µí†µ ì˜ë¯¸ ê·œì¹™ì˜ ë‹¨ì¼ ì§„ì‹¤ ì›ì²œ(SSOT)
# ============================================================================
# ì´ íŒŒì¼ì€ MCPì™€ UIê°€ ê³µí†µìœ¼ë¡œ ì°¸ì¡°í•˜ëŠ” ê·œì¹™ì…ë‹ˆë‹¤.
# ì¤‘ë³µì„ ë°©ì§€í•˜ê³  ì¼ê´€ì„±ì„ ìœ ì§€í•˜ê¸° ìœ„í•´ ì´ íŒŒì¼ë§Œ ìˆ˜ì •í•˜ì„¸ìš”.
#
# âš ï¸ SSOT ì›ì¹™ (v1.1 - ê²°ì •ë¡  ê°•í™”):
#   - ë²„ì „: versioning ì„¹ì…˜ë§Œ ì±…ì„
#   - ì„¹ì…˜/ê·¸ë£¹: schemaLogic.sectionRulesë§Œ ì±…ì„
#   - ë˜í¼: wrapperRegistryë§Œ ì±…ì„ (priority ì—†ìœ¼ë©´ defaultHandlers.wrapperPriorityDefault ì ìš©)
#   - ì»´í¬ë„ŒíŠ¸: componentRegistryë§Œ ì±…ì„
#   - ë§ˆì»¤: markerRegistry.idê°€ SSOT
#     â†’ íŠ¸ë¦¬ê±° ë¬¸ìì—´ì€ ëŸ°íƒ€ì„ì—ì„œ "has-marker:<MARKER_ID>" ìë™ ìƒì„±
#     â†’ triggerId í•„ë“œ ì—†ìŒ (ì¤‘ë³µ ì œê±°)
#   - ì¡°ê±´: êµ¬ì¡°í™”ëœ condition ê°ì²´ ì‚¬ìš© (ë¬¸ìì—´ í•˜ë“œì½”ë”© ê¸ˆì§€)
#     â†’ ì˜ˆ: { type: "has-marker", markerId: "MARKER_ENUM_BY_TYPE" }
#
# âš ï¸ ê²€ì¦ ê²½ê³„:
#   - shared.yaml ê²€ì¦ â†’ shared.meta.schema.json (CI)
#   - ì…ë ¥ ìŠ¤í‚¤ë§ˆ ê²€ì¦ â†’ unknownPolicy (ëŸ°íƒ€ì„)
#
# âš ï¸ ë©”íƒ€ìŠ¤í‚¤ë§ˆ: shared.meta.schema.json
# ============================================================================

# ============================================================================
# VERSIONING - ë²„ì „ ê´€ë¦¬ (ìœ ì¼í•œ ë²„ì „ SSOT)
# ============================================================================
versioning:
  rulesSpecVersion: "1.5.0"  # ğŸ”¥ SSOT 100ì : integrityRules + x-ui.sectionId
  inputSpec:
    schemaDraft: "draft-07"
    min: "1.0"
    max: "1.x"

# ============================================================================
# UNKNOWN POLICY - ì…ë ¥ ìŠ¤í‚¤ë§ˆ unknown í‚¤ ì²˜ë¦¬ (ëŸ°íƒ€ì„ìš©)
# ============================================================================
# âš ï¸ ì´ ì •ì±…ì€ Enhanced JSON Schema íŒŒì‹± ì‹œ ì ìš©ë¨
#    shared.yaml ìì²´ì˜ unknown í‚¤ëŠ” meta-schemaê°€ ê²€ì¦
unknownPolicy:
  transform:
    action: "passthrough"
    collectUnknown: true
  validate:
    unknownKey: "warn"
    unknownMarker: "warn"
    unsupportedStructure: "error"

# ============================================================================
# DEFAULT HANDLERS
# ============================================================================
defaultHandlers:
  typeInferenceFallback:
    type: "string"
    warn: true
  
  missingXui:
    label: "{key}"
    warn: true
  
  # ğŸ”¥ wrapperRegistry priority ì—†ì„ ë•Œ ì ìš©ë˜ëŠ” ê¸°ë³¸ê°’
  # ëŸ°íƒ€ì„ì—ì„œ ë°˜ë“œì‹œ ì´ ê°’ì„ ì‚¬ìš©í•´ì•¼ ê²°ì •ë¡  ë³´ì¥
  wrapperPriorityDefault: 0

# ============================================================================
# PRECEDENCE - ê·œì¹™ ìš°ì„ ìˆœìœ„ ì •ì˜ (ê²°ì •ë¡  ë³´ì¥)
# ============================================================================
# âš ï¸ ì ìš© ë²”ìœ„: ëª¨ë“  ë£° ì„¸íŠ¸ (wrapperRegistry, markerRegistry, sectionRules ë“±)
# âš ï¸ Merge ì „ëµ:
#   - ë™ì¼ í‚¤ â†’ ìƒìœ„ ìš°ì„ ìˆœìœ„ê°€ override (deep merge ì•„ë‹˜)
#   - ë¦¬ìŠ¤íŠ¸ â†’ ìƒìœ„ ìš°ì„ ìˆœìœ„ê°€ ì „ì²´ ëŒ€ì²´ (concat ì•„ë‹˜)
#   - ì—†ëŠ” í‚¤ â†’ í•˜ìœ„ ìš°ì„ ìˆœìœ„ì—ì„œ ìƒì†
precedence:
  order:
    - explicit    # ìŠ¤í‚¤ë§ˆ ë‚´ë¶€ x-schema-rules (ìµœìš°ì„ )
    - product     # ì œí’ˆë³„ ui.yaml, mcp.yaml
    - module      # ëª¨ë“ˆë³„ override (í–¥í›„)
    - shared      # ê³µí†µ shared.yaml
    - inference   # íƒ€ì… ì¶”ë¡  ê¸°ë³¸ê°’
  merge:
    sameKey: "override"      # ë™ì¼ í‚¤ â†’ ìƒìœ„ê°€ ë®ì–´ì”€
    list: "replace"          # ë¦¬ìŠ¤íŠ¸ â†’ ì „ì²´ ëŒ€ì²´
    missingKey: "inherit"    # ì—†ëŠ” í‚¤ â†’ í•˜ìœ„ì—ì„œ ìƒì†

# ============================================================================
# INTEGRITY RULES - ë ˆí¼ëŸ°ìŠ¤ ë¬´ê²°ì„± (SSOT)
# ============================================================================
# âš ï¸ ì´ ê·œì¹™ìœ¼ë¡œ ì°¸ì¡° ì¡´ì¬ ì—¬ë¶€ë¥¼ ëŸ°íƒ€ì„/CIì—ì„œ ê²€ì¦
integrityRules:
  # markerIdëŠ” ë°˜ë“œì‹œ markerRegistry.idì— ì¡´ì¬í•´ì•¼ í•¨
  requireMarkerIdInRegistry: true
  # sectionIdëŠ” ë°˜ë“œì‹œ sectionRegistry.idì— ì¡´ì¬í•´ì•¼ í•¨
  requireSectionIdInRegistry: true
  # condition.typeì€ ë°˜ë“œì‹œ conditionRegistry.typeì— ì¡´ì¬í•´ì•¼ í•¨
  requireConditionTypeInRegistry: true
  # x-ui.sectionIdëŠ” ë°˜ë“œì‹œ sectionRegistry.idì— ì¡´ì¬í•´ì•¼ í•¨
  requireXuiSectionIdInRegistry: true

# ============================================================================
# REGISTRIES
# ============================================================================

# ============================================================================
# MARKER REGISTRY - ìˆœìˆ˜ UI ë§ˆì»¤ë§Œ ë“±ë¡ (pureUI: true)
# ============================================================================
# âš ï¸ í•µì‹¬ ì›ì¹™: "x-* ì œê±°í•´ë„ ê²€ì¦ ë™ì‘ 100% ë™ì¼"
#   - ê²€ì¦ ë¡œì§ â†’ í‘œì¤€ JSON Schema í‚¤ì›Œë“œ (allOf if/then/required/enum)
#   - UI í‘œí˜„ â†’ x-* ë§ˆì»¤ (ì‚­ì œ ê°€ëŠ¥)
#
# âš ï¸ ê³¼ê±° ê²€ì¦ ë¡œì§ ë§ˆì»¤ (ë” ì´ìƒ ì‚¬ìš© ê¸ˆì§€):
#   - x-required-by-type â†’ allOf[].if.then.required ì‚¬ìš©
#   - x-enum-by-type â†’ allOf[].if.then.properties.*.enum ì‚¬ìš©
#   - x-node-count-by-type â†’ allOf[].if.then.properties.NODE.minItems/maxItems ì‚¬ìš©
#   - x-required-when â†’ allOf[].if.then.required ì‚¬ìš©
# ============================================================================
markerRegistry:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # UI ë©”íƒ€ë°ì´í„° (label, groupId, hint)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: MARKER_UI
    key: "x-ui"
    description: "UI ë©”íƒ€ë°ì´í„° (label, groupId, hint)"
    pureUI: true  # ì‚­ì œí•´ë„ ê²€ì¦ ì˜í–¥ ì—†ìŒ
    schema:
      type: object
      properties:
        label: { type: string, description: "í•„ë“œ ë¼ë²¨ (UI í‘œì‹œìš©)" }
        groupId: { type: string, description: "ê·¸ë£¹ ID (ì„¹ì…˜ ë¶„ë¥˜ìš©)" }
        hint: { type: string, description: "íŒíŠ¸ í…ìŠ¤íŠ¸" }
        sectionId: { type: string, description: "ì„¹ì…˜ ID (sectionRegistry ì°¸ì¡°)" }

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ì „ì†¡ ë©”íƒ€ë°ì´í„° (API ì •ë³´)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: MARKER_TRANSPORT
    key: "x-transport"
    description: "Transport ì •ë³´ (uri, method, bodyRoot)"
    pureUI: true

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Enum ë¼ë²¨ (ê²€ì¦ X, UI í‘œì‹œìš© ë¼ë²¨ë§Œ)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: MARKER_ENUM_LABELS
    key: "x-enum-labels"
    description: "enum ê°’ì— ëŒ€í•œ ë¼ë²¨ (UI í‘œì‹œìš©, ê²€ì¦ ë¬´ê´€)"
    pureUI: true
    example: |
      x-enum-labels:
        "1": "Pretension"
        "2": "Horizontal"
        "3": "Lu"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # TYPEë³„ Enum ë¼ë²¨ (ê²€ì¦ X, UI í‘œì‹œìš© ë¼ë²¨ë§Œ)
  # âš ï¸ ì‹¤ì œ enum ê°’ì€ allOf[].if.thenì—ì„œ ì •ì˜
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: MARKER_ENUM_LABELS_BY_TYPE
    key: "x-enum-labels-by-type"
    description: "TYPEë³„ enum ë¼ë²¨ (UI í‘œì‹œìš©, ê²€ì¦ ë¬´ê´€)"
    pureUI: true
    example: |
      x-enum-labels-by-type:
        TENSTR:
          "1": "Truss"
          "2": "Hook"
          "3": "Cable"
        COMPTR:
          "1": "Truss"
          "2": "Gap"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ê°’ íŒíŠ¸ (ê²€ì¦ X, ê¶Œì¥ì‚¬í•­ë§Œ)
  # âš ï¸ ì‹¤ì œ ê°’ ì œì•½ì€ allOf[].if.thenì—ì„œ ì •ì˜
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: MARKER_VALUE_HINTS
    key: "x-value-hints-by-type"
    description: "TYPEë³„ ê°’ íŒíŠ¸ (ê¶Œì¥ì‚¬í•­, ê²€ì¦ ë¬´ê´€)"
    pureUI: true
    example: |
      x-value-hints-by-type:
        TENSTR: "ê¶Œì¥: ìŒìˆ˜ ì…ë ¥ (ì••ì¶• í—ˆìš©ì¹˜)"
        COMPTR: "ê¶Œì¥: ì–‘ìˆ˜ ì…ë ¥ (ì¸ì¥ í—ˆìš©ì¹˜)"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # UI ê·œì¹™ (ê°€ì‹œì„± ì¡°ê±´ ë“±)
  # âš ï¸ ê²€ì¦ì€ allOf if/then, ì´ê²ƒì€ ìˆœìˆ˜ UI ê°€ì‹œì„±ë§Œ
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - id: MARKER_UI_RULES
    key: "x-uiRules"
    description: "UI ê°€ì‹œì„±/ë™ì‘ ê·œì¹™ (visibleWhen ë“±)"
    pureUI: true
    example: |
      x-uiRules:
        visibleWhen:
          TYPE: "TENSTR"
          STYPE: 3

# ============================================================================
# CONDITION REGISTRY - condition type taxonomy (ì „ì—­ SSOT)
# ============================================================================
# âš ï¸ ëª¨ë“  condition.typeì€ ì—¬ê¸° ë“±ë¡ëœ ê²ƒë§Œ ìœ íš¨ (schemaLogic/mcp/ui ê³µí†µ)
# âš ï¸ ëŸ°íƒ€ì„ì€ ì´ ë ˆì§€ìŠ¤íŠ¸ë¦¬ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê²€ì¦
conditionRegistry:
  - type: "has-marker"
    requiredParams: ["markerId"]
    description: "markerRegistry.id ì°¸ì¡°, í•´ë‹¹ ë§ˆì»¤ ì¡´ì¬ ì‹œ true"

  - type: "has-enum"
    requiredParams: []
    description: "ëª…ì‹œì  enum ë°°ì—´ ì¡´ì¬ ì‹œ true"

  - type: "has-oneOf-with-const"
    requiredParams: []
    description: "oneOf ë‚´ë¶€ì— const ì†ì„± ì¡´ì¬ ì‹œ true"

  - type: "has-minItems"
    requiredParams: []
    description: "minItems ì†ì„± ì¡´ì¬ ì‹œ true"

  - type: "has-maxItems"
    requiredParams: []
    description: "maxItems ì†ì„± ì¡´ì¬ ì‹œ true"

  - type: "has-type"
    requiredParams: []
    description: "type ì†ì„± ì¡´ì¬ ì‹œ true"

  - type: "has-explicit-sectionId"
    requiredParams: []
    description: "x-ui.sectionIdê°€ ëª…ì‹œì ìœ¼ë¡œ ì¡´ì¬ ì‹œ true (x-ui.groupì€ deprecated)"

  - type: "always"
    requiredParams: []
    description: "í•­ìƒ true (ê¸°ë³¸ fallback)"

  - type: "no-conditional-marker"
    requiredParams: []
    description: "x-required-when/x-optional-whenì´ ì—†ìœ¼ë©´ true"

  - type: "has-field-condition"
    requiredParams: ["field"]
    description: "íŠ¹ì • í•„ë“œ ì¡°ê±´ ì¡´ì¬ ì‹œ true"

  - type: "has-other-conditions"
    requiredParams: []
    description: "ê¸°íƒ€ ì¡°ê±´ ì¡´ì¬ ì‹œ true"

# ============================================================================
# SECTION REGISTRY - ì„¹ì…˜ ì¤‘ì•™ ê´€ë¦¬ (SSOT)
# ============================================================================
# âš ï¸ sectionRulesì™€ sectionOrderëŠ” ì—¬ê¸° ë“±ë¡ëœ idë§Œ ì°¸ì¡°
sectionRegistry:
  - id: SECTION_GENERAL
    name: "General"
    description: "ê¸°ë³¸ ì„¹ì…˜"
    isDefault: true

# 2. Wrapper Rules ë ˆì§€ìŠ¤íŠ¸ë¦¬ (SSOT)
# âš ï¸ ë§¤ì¹­ ì•Œê³ ë¦¬ì¦˜ (ê²°ì •ë¡  ë³´ì¥):
#   1. priority DESC ì •ë ¬ (ì—†ìœ¼ë©´ defaultHandlers.wrapperPriorityDefault ì ìš©)
#   2. ë™ë¥ ì´ë©´ ë¦¬ìŠ¤íŠ¸ ìˆœì„œ ìœ ì§€ (stable sort í•„ìˆ˜)
#   3. ì²« ë§¤ì¹­ rule ë°˜í™˜ (short-circuit)

# ğŸ”¥ v1.4: ì •ì±…ì„ YAMLë¡œ ì„ ì–¸ (SSOT)
wrapperRegistryPolicy:
  sort: "priorityDescStable"   # priority DESC + stable sort
  match: "first"               # ì²« ë§¤ì¹­ ë°˜í™˜

wrapperRegistry:
  - id: WRAP_DB
    pattern: "^/db/"
    wrapper: "Assign"
    priority: 10

  - id: WRAP_POST
    pattern: "^/post/"
    wrapper: "Argument"
    priority: 10

  - id: WRAP_DOC
    pattern: "^/doc/"
    wrapper: "Argument"
    priority: 10

  - id: WRAP_DEFAULT
    pattern: ".*"
    wrapper: null
    priority: -1

# 3. íƒ€ì… ì ‘ë‘ì‚¬ ì¶”ë¡  ë ˆì§€ìŠ¤íŠ¸ë¦¬
typeInferenceRegistry:
  - id: TYPE_INT
    prefix: "i"
    type: "integer"
    example: "iTENDON_TYPE"

  - id: TYPE_BOOL
    prefix: "b"
    type: "boolean"
    example: "bCRACK_CHECK"

  - id: TYPE_NUM
    prefix: "d"
    type: "number"
    example: "dEXPOSURE_VALUE"

  - id: TYPE_STR
    prefix: "s"
    type: "string"
    example: "sCODE_NAME"

# 4. í•„ë“œ íƒ€ì… â†’ UI ì»´í¬ë„ŒíŠ¸ ë ˆì§€ìŠ¤íŠ¸ë¦¬ (SSOT)
componentRegistry:
  string:
    component: "Input"
    props: { type: "text" }

  number:
    component: "Input"
    props: { type: "number" }

  integer:
    component: "Input"
    props: { type: "number" }

  boolean:
    component: "Checkbox"
    props: {}

  array:
    component: "Textarea"
    props: { placeholder: "Enter as JSON array, e.g., [1, 2, 3]" }

  object:
    component: "Textarea"
    props: { placeholder: "Enter as JSON object" }

  enum:
    component: "Select"
    props: {}

# ============================================================================
# NAMING POLICY
# ============================================================================
naming:
  yamlKeyPolicy:
    min: 3
    max: 20
    style: "camelCase"
  
  fieldNamePolicy:
    # ğŸ”¥ v1.4: íŒŒìƒ ê·œì¹™ì„ YAMLë¡œ ì„ ì–¸ (SSOT)
    prefixSource: "typeInferenceRegistry"  # allowedPrefixes = typeInferenceRegistry.map(prefix)
    allowUppercase: true
    maxLength: 30
  
  conflict:
    strategy: "suffix"
    format: "{key}_{n}"

# ============================================================================
# OUTPUT META - ì¶œë ¥ ë©”íƒ€ë°ì´í„° í…œí”Œë¦¿
# ============================================================================
# âš ï¸ source ê²½ë¡œ ê·œì¹™:
#   - versioning.* : shared.yamlì—ì„œ ì§ì ‘ ì½ìŒ
#   - _computed.*  : ëŸ°íƒ€ì„ì—ì„œ ê³„ì‚° (sourceHash, outputHash ë“±)
# âš ï¸ ì—ëŸ¬ ì •ì±…:
#   - required: true â†’ í•´ì„ ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ (í”„ë¡œì„¸ìŠ¤ ì¤‘ë‹¨)
#   - required: false + onMissing: warn â†’ ê²½ê³  + null
#   - required: false + onMissing: null â†’ ì¡°ìš©íˆ null
outputMeta:
  # ê¸°ë³¸ ì—ëŸ¬ ì •ì±… (ê°œë³„ í•„ë“œì—ì„œ override ê°€ëŠ¥)
  defaults:
    required: false
    onMissing: "warn"  # "warn" | "error" | "null"
  fields:
    - alias: "rulesSpecVersion"
      source: "versioning.rulesSpecVersion"
      required: true  # í•„ìˆ˜ - ì—†ìœ¼ë©´ ì—ëŸ¬
    - alias: "sourceHash"
      source: "_computed.sourceHash"
    - alias: "outputHash"
      source: "_computed.outputHash"
    - alias: "generatedAt"
      source: "_computed.generatedAt"
      required: true  # í•„ìˆ˜
    - alias: "appliedRuleIds"
      source: "_computed.appliedRuleIds"
    - alias: "warnings"
      source: "_computed.warnings"
      onMissing: "null"  # ê²½ê³  ì—†ì´ null
    - alias: "unknownKeys"
      source: "_computed.unknownKeys"
      onMissing: "null"  # ê²½ê³  ì—†ì´ null

# ============================================================================
# DIAGNOSTICS - ì§„ë‹¨ ì½”ë“œ ì²´ê³„
# ============================================================================
diagnostics:
  errors:
    - code: "ENUM_INVALID_FORMAT"
      level: "error"
      message: "ì •ìˆ˜ enumì€ oneOf í˜•ì‹ í•„ìˆ˜"
      fix: "auto-convert"

    - code: "PREFIX_TYPE_MISMATCH"
      level: "error"
      message: "ì ‘ë‘ì‚¬ì™€ íƒ€ì… ë¶ˆì¼ì¹˜: {field}ëŠ” {expected} íƒ€ì…ì´ì–´ì•¼ í•¨"

    - code: "UNSUPPORTED_STRUCTURE"
      level: "error"
      message: "ì§€ì›í•˜ì§€ ì•ŠëŠ” ìŠ¤í‚¤ë§ˆ êµ¬ì¡°: {structure}"

    - code: "INVALID_FIELD_NAME_POLICY"
      level: "error"
      message: "í•„ë“œëª… ì •ì±… ìœ„ë°˜: {field}"

    - code: "INVALID_YAML_KEY_POLICY"
      level: "error"
      message: "YAML í‚¤ ì •ì±… ìœ„ë°˜: {key}"

    - code: "OUTPUT_META_SOURCE_NOT_FOUND"
      level: "error"
      message: "outputMeta source ê²½ë¡œ í•´ì„ ì‹¤íŒ¨: {source}"

  warnings:
    - code: "MISSING_XUI_LABEL"
      level: "warn"
      message: "x-ui.label ëˆ„ë½: {field}"
      fix: "generate-from-key"

    - code: "MISSING_XUI_GROUP"
      level: "warn"
      message: "x-ui.group ëˆ„ë½: {field}"

    - code: "UNKNOWN_KEY"
      level: "warn"
      message: "ì•Œ ìˆ˜ ì—†ëŠ” í‚¤: {key}"

    - code: "UNKNOWN_MARKER"
      level: "warn"
      message: "ì•Œ ìˆ˜ ì—†ëŠ” ë§ˆì»¤: {marker}"

# ============================================================================
# SCHEMA LOGIC - ìŠ¤í‚¤ë§ˆ ì²˜ë¦¬ ë¡œì§ (ë„¤ì„ìŠ¤í˜ì´ìŠ¤)
# ============================================================================
schemaLogic:
  schemaStructurePatterns:
    # ğŸ”¥ Pattern 1: Assign/Argument + additionalProperties (NEW)
    # ì´ íŒ¨í„´ì€ Map ê¸°ë°˜ ì—”í‹°í‹° ì»¬ë ‰ì…˜ì„ ì²˜ë¦¬
    - name: "Unwrap Wrapper with AdditionalProperties"
      description: "Assign/Argument ë˜í¼ì˜ additionalPropertiesì—ì„œ ì—”í‹°í‹° ìŠ¤í‚¤ë§ˆ ì¶”ì¶œ"
      enabled: true
      priority: 0  # ê°€ì¥ ë¨¼ì € ì²´í¬
      detect:
        - path: "type"
          value: "object"
        - path: "properties.Assign.additionalProperties"
          exists: true
        - path: "properties.Assign.additionalProperties.type"
          value: "object"
      transform:
        action: "unwrap-wrapper-with-additionalProperties"
        
    # ğŸ”¥ Pattern 1b: Argument ë˜í¼ (Assign ëŒ€ì•ˆ)
    - name: "Unwrap Argument Wrapper with AdditionalProperties"
      description: "Argument ë˜í¼ì˜ additionalPropertiesì—ì„œ ì—”í‹°í‹° ìŠ¤í‚¤ë§ˆ ì¶”ì¶œ"
      enabled: true
      priority: 0
      detect:
        - path: "type"
          value: "object"
        - path: "properties.Argument.additionalProperties"
          exists: true
        - path: "properties.Argument.additionalProperties.type"
          value: "object"
      transform:
        action: "unwrap-wrapper-with-additionalProperties"

    # Pattern 2: ê¸°ì¡´ unwrap-root-key (ë ˆê±°ì‹œ)
    - name: "Unwrap Root Wrapper Key"
      description: "ë£¨íŠ¸ ë˜í¼ í‚¤ë¥¼ ì œê±°í•˜ê³  ë‚´ë¶€ ìŠ¤í‚¤ë§ˆë¥¼ ëŒì–´ì˜¬ë¦¼"
      enabled: true
      priority: 1
      detect:
        - path: "$schema"
          exists: false
        - path: "type"
          exists: false
      transform:
        action: "unwrap-root-key"
        extractTitle: true
        preserveMetadata: ["description", "x-ui", "x-transport"]

  platformSkeleton:
    entityCollection:
      description: "Platform Standard Collection Map"
      type: "object"
      patternProperties:
        pattern: "^[0-9]+$"
        description: "Entity ID (numeric)"
        ref: "#/$defs/entity"
      additionalProperties: false
      minProperties: 0
    defaultBodyRoot: "Assign"
    alternativeBodyRoots:
      - "Argument"
      - "Assign"
    rootStructure:
      type: "object"
      additionalProperties: false

  sectionRules:
    - name: "Explicit SectionId"
      description: "x-ui.sectionIdê°€ ëª…ì‹œë˜ì–´ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš© (sectionRegistry.id ì°¸ì¡° í•„ìˆ˜)"
      condition:
        type: "has-explicit-sectionId"
      action:
        type: "use-explicit-sectionId"
        # âš ï¸ integrityRules.requireXuiSectionIdInRegistry=trueë¡œ ê²€ì¦
        # âš ï¸ x-ui.groupì€ deprecated - x-ui.sectionIdë¡œ ëŒ€ì²´
    - name: "Fallback"
      description: "ê¸°ë³¸ ì„¹ì…˜ (sectionRegistry SSOT)"
      condition:
        type: "always"
      action:
        type: "assign-section"
        sectionId: "SECTION_GENERAL"  # ğŸ”¥ sectionRegistry.id ì°¸ì¡°

  sectionOrder:
    - "SECTION_GENERAL"  # ğŸ”¥ sectionRegistry.id ì°¸ì¡°

  typeLabels: {}

  # Enum íŒì • ê·œì¹™
  # âš ï¸ êµ¬ì¡°í™”ëœ condition ì‚¬ìš© (ë¬¸ìì—´ í•˜ë“œì½”ë”© ê¸ˆì§€)
  #    markerRegistry.idë¥¼ ì§ì ‘ ì°¸ì¡°
  enumDetectionRules:
    - id: ENUM_EXPLICIT
      condition:
        type: "has-enum"
      description: "ëª…ì‹œì  enum ë°°ì—´ì´ ìˆìœ¼ë©´ enum"

    - id: ENUM_ONEOF_CONST
      condition:
        type: "has-oneOf-with-const"
      description: "oneOf ë‚´ë¶€ì— constê°€ ìˆìœ¼ë©´ enum"

    - id: ENUM_X_ENUM_BY_TYPE
      condition:
        type: "has-marker"
        markerId: "MARKER_ENUM_BY_TYPE"  # ğŸ”¥ markerRegistry.id ì°¸ì¡°
      description: "x-enum-by-type ë§ˆì»¤ê°€ ìˆìœ¼ë©´ ë™ì  enum"

  visibilityRules:
    - name: "No Conditional Marker"
      description: "x-required-when/x-optional-whenì´ ì—†ìœ¼ë©´ í•­ìƒ í‘œì‹œ"
      condition:
        type: "no-conditional-marker"
      result: true
    - name: "TYPE Condition"
      description: "TYPE í•„ë“œ ì¡°ê±´ í™•ì¸"
      condition:
        type: "has-field-condition"
        field: "TYPE"
      evaluation:
        operator: "in"
        field: "TYPE"
    - name: "Other Field Conditions"
      description: "ë‹¤ë¥¸ í•„ë“œ ì¡°ê±´ í™•ì¸"
      condition:
        type: "has-other-conditions"
      evaluation:
        operator: "all-match"

  requiredCalculationRules:
    priority:
      - "base-required"
      - "conditional-required"
      - "visibility-check"
    baseRequired:
      description: "ìµœìƒìœ„ required ë°°ì—´ì— ìˆìœ¼ë©´ ëª¨ë“  TYPEì—ì„œ required"
      status: "required"
    conditionalRequired:
      description: "allOf ì¡°ê±´ì— ë§¤ì¹­ë˜ë©´ í•´ë‹¹ TYPEì—ì„œ required"
      status: "required"
    notVisible:
      description: "ì¡°ê±´ë¶€ ë§ˆì»¤(x-required-when/x-optional-when) ì¡°ê±´ìœ¼ë¡œ ë³´ì´ì§€ ì•Šìœ¼ë©´ n/a"
      status: "n/a"
    default:
      description: "ê¸°ë³¸ê°’"
      status: "optional"

  # ê²€ì¦ ë ˆì´ì–´ ê²°ì • ê·œì¹™
  # âš ï¸ êµ¬ì¡°í™”ëœ condition ì‚¬ìš©
  validationLayerRules:
    STD:
      description: "Standard JSON Schema validation"
      triggers:
        - condition:
            type: "has-enum"
        - condition:
            type: "has-minItems"
        - condition:
            type: "has-maxItems"
        - condition:
            type: "has-type"
    APP:
      description: "Application-specific validation"
      triggers:
        - condition:
            type: "has-marker"
            markerId: "MARKER_ENUM_BY_TYPE"
        - condition:
            type: "has-marker"
            markerId: "MARKER_NODE_COUNT"
        - condition:
            type: "has-marker"
            markerId: "MARKER_VALUE_CONSTRAINT"

  descriptionBuildingRules:
    order:
      - label
      - enum-values
      - enum-by-type
      - value-constraints
      - node-count-by-type
      - hint
    templates:
      label: "<strong>{label}</strong>"
      enum-values:
        header: "<strong>Enum Values:</strong>"
        item: "<li><code>{value}</code> - {label}</li>"
        wrapper: "<ul>{items}</ul>"
      enum-by-type:
        header: "<strong>Enum Values by Type:</strong>"
        type-header: "<p><em>{type}:</em></p>"
        item: "<li><code>{value}</code> - {label}</li>"
        wrapper: "<ul>{items}</ul>"
      value-constraints:
        header: "<strong>Value Constraints:</strong>"
        item: "<li><em>{type}:</em> {constraint}</li>"
        wrapper: "<ul>{items}</ul>"
      node-count-by-type:
        header: "<strong>Node Count by Type:</strong>"
        item: "<li><em>{type}:</em> {count} nodes</li>"
        wrapper: "<ul>{items}</ul>"
      hint: '<p class="hint">{hint}</p>'

# ============================================================================
# SCHEMA STRUCTURE PATTERNS - ìŠ¤í‚¤ë§ˆ êµ¬ì¡° ê°ì§€ ë° ë³€í™˜ ê·œì¹™
# ============================================================================
# âš ï¸ ì´ íŒ¨í„´ë“¤ì€ schemaCompilerê°€ ìŠ¤í‚¤ë§ˆë¥¼ íŒŒì‹±í•  ë•Œ ì‚¬ìš©ë¨
#   - ë˜í¼ ê°ì§€: Assign, Argument ë“±ì˜ ë˜í¼ í‚¤
#   - ì—”í‹°í‹° ì¶”ì¶œ: additionalProperties ë‚´ë¶€ ìŠ¤í‚¤ë§ˆë¥¼ ì¶”ì¶œ
#   - allOf ì²˜ë¦¬: if/then ì¡°ê±´ë¶€ ê²€ì¦ ë¡œì§
# ============================================================================
schemaStructurePatterns:
  # ğŸ”¥ ë˜í¼ í‚¤ ì •ì˜ (API body-root)
  wrapperKeys:
    - key: "Assign"
      description: "DB PUT/POST - Map ê¸°ë°˜ ë‹¤ì¤‘ ì—”í‹°í‹°"
      example: '{ "Assign": { "1": {...}, "2": {...} } }'
    - key: "Argument"
      description: "Function Call - ë‹¨ì¼ ì¸ì ê°ì²´"
      example: '{ "Argument": {...} }'

  # ğŸ”¥ ì—”í‹°í‹° ì»¬ë ‰ì…˜ íŒ¨í„´ (Assign/Argument ë‚´ë¶€ êµ¬ì¡°)
  entityCollectionPattern:
    # íŒ¨í„´ ê°ì§€ ì¡°ê±´ (ëª¨ë‘ ë§Œì¡±í•´ì•¼ í•¨)
    detect:
      - path: "properties.*.type"
        value: "object"
      - path: "properties.*.additionalProperties"
        exists: true
    # ì—”í‹°í‹° ì¶”ì¶œ ìœ„ì¹˜
    entityPath: "properties.{wrapperKey}.additionalProperties"
    # ì—”í‹°í‹° ìŠ¤í‚¤ë§ˆì—ì„œ í•„ë“œ ì¶”ì¶œ
    fieldExtractionRules:
      properties: "properties"
      required: "required"
      allOf: "allOf"
      xUi: "x-ui"

  # ğŸ”¥ allOf if/then íŒ¨í„´ - ì¡°ê±´ë¶€ ê²€ì¦ ë¡œì§
  conditionalValidation:
    # allOf ë°°ì—´ì—ì„œ if/then ë¸”ë¡ ì¶”ì¶œ
    pattern: "allOf[*].{if,then}"
    # if ë¸”ë¡ êµ¬ì¡°
    ifStructure:
      properties: "properties"     # { TYPE: { const: "BEAM" } }
      required: "required"         # ["TYPE"]
    # then ë¸”ë¡ êµ¬ì¡°
    thenStructure:
      required: "required"         # ì¡°ê±´ë¶€ required í•„ë“œë“¤
      properties: "properties"     # ì¡°ê±´ë¶€ enum, minItems, maxItems ë“±

  # ğŸ”¥ ì¡°ê±´ë¶€ required ë§¤í•‘ ìƒì„± ê·œì¹™
  conditionalRequiredMapping:
    # allOf[].if.properties.TYPE.const â†’ conditionValue
    # allOf[].then.required â†’ requiredFields
    # ê²°ê³¼: { "BEAM": ["SECT"], "TENSTR": ["SECT", "STYPE", "NON_LEN"], ... }
    conditionField: "TYPE"  # ê¸°ë³¸ ì¡°ê±´ í•„ë“œ (ëŒ€ë¶€ë¶„ TYPE)
    multiCondition: true    # TYPE + STYPE ê°™ì€ ë³µí•© ì¡°ê±´ ì§€ì›

  # ğŸ”¥ ì¡°ê±´ë¶€ enum ë§¤í•‘ ìƒì„± ê·œì¹™
  conditionalEnumMapping:
    # allOf[].if.properties.TYPE.const â†’ conditionValue
    # allOf[].then.properties.STYPE.enum â†’ enumValues
    # ê²°ê³¼: { "TENSTR": [1,2,3], "COMPTR": [1,2], ... }
    extractFrom: "allOf[*].then.properties.*.enum"

  # ğŸ”¥ ì¡°ê±´ë¶€ NODE ê°œìˆ˜ ë§¤í•‘ ìƒì„± ê·œì¹™
  conditionalNodeCountMapping:
    # allOf[].if.properties.TYPE.const â†’ conditionValue
    # allOf[].then.properties.NODE.minItems/maxItems â†’ nodeCount
    # ê²°ê³¼: { "BEAM": { min: 2, max: 2 }, "PLATE": { min: 3, max: 4 }, ... }
    extractFrom: "allOf[*].then.properties.NODE.{minItems,maxItems}"

  # ğŸ”¥ x-uiRules.visibleWhen ì²˜ë¦¬
  uiVisibilityRules:
    markerKey: "x-uiRules"
    visibleWhenPath: "visibleWhen"
    # ì¡°ê±´ í•„ë“œ (TYPE, STYPE ë“±)
    supportedConditionFields:
      - "TYPE"
      - "STYPE"
      - "iMETHOD"
      - "bSELFWEIGHT"
    # ì¡°ê±´ í˜•ì‹ ì§€ì›
    conditionFormats:
      single: "{ TYPE: 'TENSTR' }"           # ë‹¨ì¼ ê°’
      multi: "{ TYPE: 'TENSTR', STYPE: 3 }"  # ë³µí•© ì¡°ê±´
