# ============================================================================
# SHARED RULES - ê³µí†µ ì˜ë¯¸ ê·œì¹™ì˜ ë‹¨ì¼ ì§„ì‹¤ ì›ì²œ(SSOT)
# ============================================================================
# ì´ íŒŒì¼ì€ MCPì™€ UIê°€ ê³µí†µìœ¼ë¡œ ì°¸ì¡°í•˜ëŠ” ê·œì¹™ì…ë‹ˆë‹¤.
# ì¤‘ë³µì„ ë°©ì§€í•˜ê³  ì¼ê´€ì„±ì„ ìœ ì§€í•˜ê¸° ìœ„í•´ ì´ íŒŒì¼ë§Œ ìˆ˜ì •í•˜ì„¸ìš”.
#
# âš ï¸ SSOT ì›ì¹™ (v1.1 - ê²°ì •ë¡  ê°•í™”):
#   - ë²„ì „: versioning ì„¹ì…˜ë§Œ ì±…ì„
#   - ì„¹ì…˜/ê·¸ë£¹: schemaLogic.sectionRulesë§Œ ì±…ì„
#   - ë˜í¼: wrapperRegistryë§Œ ì±…ì„ (priority ì—†ìœ¼ë©´ defaultHandlers.wrapperPriorityDefault ì ìš©)
#   - ì»´í¬ë„ŒíŠ¸: componentRegistryë§Œ ì±…ì„
#   - ë§ˆì»¤: markerRegistry.idê°€ SSOT
#     â†’ íŠ¸ë¦¬ê±° ë¬¸ìì—´ì€ ëŸ°íƒ€ì„ì—ì„œ "has-marker:<MARKER_ID>" ìë™ ìƒì„±
#     â†’ triggerId í•„ë“œ ì—†ìŒ (ì¤‘ë³µ ì œê±°)
#   - ì¡°ê±´: êµ¬ì¡°í™”ëœ condition ê°ì²´ ì‚¬ìš© (ë¬¸ìì—´ í•˜ë“œì½”ë”© ê¸ˆì§€)
#     â†’ ì˜ˆ: { type: "has-marker", markerId: "MARKER_ENUM_BY_TYPE" }
#
# âš ï¸ ê²€ì¦ ê²½ê³„:
#   - shared.yaml ê²€ì¦ â†’ shared.meta.schema.json (CI)
#   - ì…ë ¥ ìŠ¤í‚¤ë§ˆ ê²€ì¦ â†’ unknownPolicy (ëŸ°íƒ€ì„)
#
# âš ï¸ ë©”íƒ€ìŠ¤í‚¤ë§ˆ: shared.meta.schema.json
# ============================================================================

# ============================================================================
# VERSIONING - ë²„ì „ ê´€ë¦¬ (ìœ ì¼í•œ ë²„ì „ SSOT)
# ============================================================================
versioning:
  rulesSpecVersion: "1.5.0"  # ğŸ”¥ SSOT 100ì : integrityRules + x-ui.sectionId
  inputSpec:
    schemaDraft: "draft-07"
    min: "1.0"
    max: "1.x"

# ============================================================================
# UNKNOWN POLICY - ì…ë ¥ ìŠ¤í‚¤ë§ˆ unknown í‚¤ ì²˜ë¦¬ (ëŸ°íƒ€ì„ìš©)
# ============================================================================
# âš ï¸ ì´ ì •ì±…ì€ Enhanced JSON Schema íŒŒì‹± ì‹œ ì ìš©ë¨
#    shared.yaml ìì²´ì˜ unknown í‚¤ëŠ” meta-schemaê°€ ê²€ì¦
unknownPolicy:
  transform:
    action: "passthrough"
    collectUnknown: true
  validate:
    unknownKey: "warn"
    unknownMarker: "warn"
    unsupportedStructure: "error"

# ============================================================================
# DEFAULT HANDLERS
# ============================================================================
defaultHandlers:
  typeInferenceFallback:
    type: "string"
    warn: true
  
  missingXui:
    label: "{key}"
    warn: true
  
  # ğŸ”¥ wrapperRegistry priority ì—†ì„ ë•Œ ì ìš©ë˜ëŠ” ê¸°ë³¸ê°’
  # ëŸ°íƒ€ì„ì—ì„œ ë°˜ë“œì‹œ ì´ ê°’ì„ ì‚¬ìš©í•´ì•¼ ê²°ì •ë¡  ë³´ì¥
  wrapperPriorityDefault: 0

# ============================================================================
# PRECEDENCE - ê·œì¹™ ìš°ì„ ìˆœìœ„ ì •ì˜ (ê²°ì •ë¡  ë³´ì¥)
# ============================================================================
# âš ï¸ ì ìš© ë²”ìœ„: ëª¨ë“  ë£° ì„¸íŠ¸ (wrapperRegistry, markerRegistry, sectionRules ë“±)
# âš ï¸ Merge ì „ëµ:
#   - ë™ì¼ í‚¤ â†’ ìƒìœ„ ìš°ì„ ìˆœìœ„ê°€ override (deep merge ì•„ë‹˜)
#   - ë¦¬ìŠ¤íŠ¸ â†’ ìƒìœ„ ìš°ì„ ìˆœìœ„ê°€ ì „ì²´ ëŒ€ì²´ (concat ì•„ë‹˜)
#   - ì—†ëŠ” í‚¤ â†’ í•˜ìœ„ ìš°ì„ ìˆœìœ„ì—ì„œ ìƒì†
precedence:
  order:
    - explicit    # ìŠ¤í‚¤ë§ˆ ë‚´ë¶€ x-schema-rules (ìµœìš°ì„ )
    - product     # ì œí’ˆë³„ ui.yaml, mcp.yaml
    - module      # ëª¨ë“ˆë³„ override (í–¥í›„)
    - shared      # ê³µí†µ shared.yaml
    - inference   # íƒ€ì… ì¶”ë¡  ê¸°ë³¸ê°’
  merge:
    sameKey: "override"      # ë™ì¼ í‚¤ â†’ ìƒìœ„ê°€ ë®ì–´ì”€
    list: "replace"          # ë¦¬ìŠ¤íŠ¸ â†’ ì „ì²´ ëŒ€ì²´
    missingKey: "inherit"    # ì—†ëŠ” í‚¤ â†’ í•˜ìœ„ì—ì„œ ìƒì†

# ============================================================================
# INTEGRITY RULES - ë ˆí¼ëŸ°ìŠ¤ ë¬´ê²°ì„± (SSOT)
# ============================================================================
# âš ï¸ ì´ ê·œì¹™ìœ¼ë¡œ ì°¸ì¡° ì¡´ì¬ ì—¬ë¶€ë¥¼ ëŸ°íƒ€ì„/CIì—ì„œ ê²€ì¦
integrityRules:
  # markerIdëŠ” ë°˜ë“œì‹œ markerRegistry.idì— ì¡´ì¬í•´ì•¼ í•¨
  requireMarkerIdInRegistry: true
  # sectionIdëŠ” ë°˜ë“œì‹œ sectionRegistry.idì— ì¡´ì¬í•´ì•¼ í•¨
  requireSectionIdInRegistry: true
  # condition.typeì€ ë°˜ë“œì‹œ conditionRegistry.typeì— ì¡´ì¬í•´ì•¼ í•¨
  requireConditionTypeInRegistry: true
  # x-ui.sectionIdëŠ” ë°˜ë“œì‹œ sectionRegistry.idì— ì¡´ì¬í•´ì•¼ í•¨
  requireXuiSectionIdInRegistry: true

# ============================================================================
# REGISTRIES
# ============================================================================

# 1. Enhanced Schema ê°ì§€ ë§ˆì»¤ ë ˆì§€ìŠ¤íŠ¸ë¦¬ (SSOT)
# âš ï¸ idê°€ SSOT - triggerId í•„ë“œ ì—†ìŒ (ìë™ ìƒì„± ê·œì¹™ìœ¼ë¡œ ëŒ€ì²´)
#    íŠ¸ë¦¬ê±° ë¬¸ìì—´ = "has-marker:<id>" (ëŸ°íƒ€ì„ì—ì„œ ìë™ ìƒì„±)
markerRegistry:
  - id: MARKER_UI
    key: "x-ui"
    description: "UI ë©”íƒ€ë°ì´í„° (label, group, hint, visibleWhen)"
    required: false

  - id: MARKER_TRANSPORT
    key: "x-transport"
    description: "Transport ì •ë³´ (min, max, layer)"
    required: false

  - id: MARKER_ENUM_BY_TYPE
    key: "x-enum-by-type"
    description: "TYPEë³„ ë™ì  enum"
    required: false

  - id: MARKER_NODE_COUNT
    key: "x-node-count-by-type"
    description: "TYPEë³„ ë…¸ë“œ ê°œìˆ˜"
    required: false

  - id: MARKER_VALUE_CONSTRAINT
    key: "x-value-constraint"
    description: "ê°’ ì œì•½ ì¡°ê±´"
    required: false

  - id: MARKER_REQUIRED_BY_TYPE
    key: "x-required-by-type"
    description: "TYPEë³„ required ìƒíƒœ"
    required: false

  - id: MARKER_ENUM_LABELS_BY_TYPE
    key: "x-enum-labels-by-type"
    description: "TYPEë³„ enum ë¼ë²¨"
    required: false

# ============================================================================
# CONDITION REGISTRY - condition type taxonomy (ì „ì—­ SSOT)
# ============================================================================
# âš ï¸ ëª¨ë“  condition.typeì€ ì—¬ê¸° ë“±ë¡ëœ ê²ƒë§Œ ìœ íš¨ (schemaLogic/mcp/ui ê³µí†µ)
# âš ï¸ ëŸ°íƒ€ì„ì€ ì´ ë ˆì§€ìŠ¤íŠ¸ë¦¬ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê²€ì¦
conditionRegistry:
  - type: "has-marker"
    requiredParams: ["markerId"]
    description: "markerRegistry.id ì°¸ì¡°, í•´ë‹¹ ë§ˆì»¤ ì¡´ì¬ ì‹œ true"

  - type: "has-enum"
    requiredParams: []
    description: "ëª…ì‹œì  enum ë°°ì—´ ì¡´ì¬ ì‹œ true"

  - type: "has-oneOf-with-const"
    requiredParams: []
    description: "oneOf ë‚´ë¶€ì— const ì†ì„± ì¡´ì¬ ì‹œ true"

  - type: "has-minItems"
    requiredParams: []
    description: "minItems ì†ì„± ì¡´ì¬ ì‹œ true"

  - type: "has-maxItems"
    requiredParams: []
    description: "maxItems ì†ì„± ì¡´ì¬ ì‹œ true"

  - type: "has-type"
    requiredParams: []
    description: "type ì†ì„± ì¡´ì¬ ì‹œ true"

  - type: "has-explicit-sectionId"
    requiredParams: []
    description: "x-ui.sectionIdê°€ ëª…ì‹œì ìœ¼ë¡œ ì¡´ì¬ ì‹œ true (x-ui.groupì€ deprecated)"

  - type: "always"
    requiredParams: []
    description: "í•­ìƒ true (ê¸°ë³¸ fallback)"

  - type: "no-visible-when"
    requiredParams: []
    description: "visibleWhenì´ ì—†ìœ¼ë©´ true"

  - type: "has-field-condition"
    requiredParams: ["field"]
    description: "íŠ¹ì • í•„ë“œ ì¡°ê±´ ì¡´ì¬ ì‹œ true"

  - type: "has-other-conditions"
    requiredParams: []
    description: "ê¸°íƒ€ ì¡°ê±´ ì¡´ì¬ ì‹œ true"

# ============================================================================
# SECTION REGISTRY - ì„¹ì…˜ ì¤‘ì•™ ê´€ë¦¬ (SSOT)
# ============================================================================
# âš ï¸ sectionRulesì™€ sectionOrderëŠ” ì—¬ê¸° ë“±ë¡ëœ idë§Œ ì°¸ì¡°
sectionRegistry:
  - id: SECTION_GENERAL
    name: "General"
    description: "ê¸°ë³¸ ì„¹ì…˜"
    isDefault: true

# 2. Wrapper Rules ë ˆì§€ìŠ¤íŠ¸ë¦¬ (SSOT)
# âš ï¸ ë§¤ì¹­ ì•Œê³ ë¦¬ì¦˜ (ê²°ì •ë¡  ë³´ì¥):
#   1. priority DESC ì •ë ¬ (ì—†ìœ¼ë©´ defaultHandlers.wrapperPriorityDefault ì ìš©)
#   2. ë™ë¥ ì´ë©´ ë¦¬ìŠ¤íŠ¸ ìˆœì„œ ìœ ì§€ (stable sort í•„ìˆ˜)
#   3. ì²« ë§¤ì¹­ rule ë°˜í™˜ (short-circuit)

# ğŸ”¥ v1.4: ì •ì±…ì„ YAMLë¡œ ì„ ì–¸ (SSOT)
wrapperRegistryPolicy:
  sort: "priorityDescStable"   # priority DESC + stable sort
  match: "first"               # ì²« ë§¤ì¹­ ë°˜í™˜

wrapperRegistry:
  - id: WRAP_DB
    pattern: "^/db/"
    wrapper: "Assign"
    priority: 10

  - id: WRAP_POST
    pattern: "^/post/"
    wrapper: "Argument"
    priority: 10

  - id: WRAP_DOC
    pattern: "^/doc/"
    wrapper: "Argument"
    priority: 10

  - id: WRAP_DEFAULT
    pattern: ".*"
    wrapper: null
    priority: -1

# 3. íƒ€ì… ì ‘ë‘ì‚¬ ì¶”ë¡  ë ˆì§€ìŠ¤íŠ¸ë¦¬
typeInferenceRegistry:
  - id: TYPE_INT
    prefix: "i"
    type: "integer"
    example: "iTENDON_TYPE"

  - id: TYPE_BOOL
    prefix: "b"
    type: "boolean"
    example: "bCRACK_CHECK"

  - id: TYPE_NUM
    prefix: "d"
    type: "number"
    example: "dEXPOSURE_VALUE"

  - id: TYPE_STR
    prefix: "s"
    type: "string"
    example: "sCODE_NAME"

# 4. í•„ë“œ íƒ€ì… â†’ UI ì»´í¬ë„ŒíŠ¸ ë ˆì§€ìŠ¤íŠ¸ë¦¬ (SSOT)
componentRegistry:
  string:
    component: "Input"
    props: { type: "text" }

  number:
    component: "Input"
    props: { type: "number" }

  integer:
    component: "Input"
    props: { type: "number" }

  boolean:
    component: "Checkbox"
    props: {}

  array:
    component: "Textarea"
    props: { placeholder: "Enter as JSON array, e.g., [1, 2, 3]" }

  object:
    component: "Textarea"
    props: { placeholder: "Enter as JSON object" }

  enum:
    component: "Select"
    props: {}

# ============================================================================
# NAMING POLICY
# ============================================================================
naming:
  yamlKeyPolicy:
    min: 3
    max: 20
    style: "camelCase"
  
  fieldNamePolicy:
    # ğŸ”¥ v1.4: íŒŒìƒ ê·œì¹™ì„ YAMLë¡œ ì„ ì–¸ (SSOT)
    prefixSource: "typeInferenceRegistry"  # allowedPrefixes = typeInferenceRegistry.map(prefix)
    allowUppercase: true
    maxLength: 30
  
  conflict:
    strategy: "suffix"
    format: "{key}_{n}"

# ============================================================================
# OUTPUT META - ì¶œë ¥ ë©”íƒ€ë°ì´í„° í…œí”Œë¦¿
# ============================================================================
# âš ï¸ source ê²½ë¡œ ê·œì¹™:
#   - versioning.* : shared.yamlì—ì„œ ì§ì ‘ ì½ìŒ
#   - _computed.*  : ëŸ°íƒ€ì„ì—ì„œ ê³„ì‚° (sourceHash, outputHash ë“±)
# âš ï¸ ì—ëŸ¬ ì •ì±…:
#   - required: true â†’ í•´ì„ ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ (í”„ë¡œì„¸ìŠ¤ ì¤‘ë‹¨)
#   - required: false + onMissing: warn â†’ ê²½ê³  + null
#   - required: false + onMissing: null â†’ ì¡°ìš©íˆ null
outputMeta:
  # ê¸°ë³¸ ì—ëŸ¬ ì •ì±… (ê°œë³„ í•„ë“œì—ì„œ override ê°€ëŠ¥)
  defaults:
    required: false
    onMissing: "warn"  # "warn" | "error" | "null"
  fields:
    - alias: "rulesSpecVersion"
      source: "versioning.rulesSpecVersion"
      required: true  # í•„ìˆ˜ - ì—†ìœ¼ë©´ ì—ëŸ¬
    - alias: "sourceHash"
      source: "_computed.sourceHash"
    - alias: "outputHash"
      source: "_computed.outputHash"
    - alias: "generatedAt"
      source: "_computed.generatedAt"
      required: true  # í•„ìˆ˜
    - alias: "appliedRuleIds"
      source: "_computed.appliedRuleIds"
    - alias: "warnings"
      source: "_computed.warnings"
      onMissing: "null"  # ê²½ê³  ì—†ì´ null
    - alias: "unknownKeys"
      source: "_computed.unknownKeys"
      onMissing: "null"  # ê²½ê³  ì—†ì´ null

# ============================================================================
# DIAGNOSTICS - ì§„ë‹¨ ì½”ë“œ ì²´ê³„
# ============================================================================
diagnostics:
  errors:
    - code: "ENUM_INVALID_FORMAT"
      level: "error"
      message: "ì •ìˆ˜ enumì€ oneOf í˜•ì‹ í•„ìˆ˜"
      fix: "auto-convert"

    - code: "PREFIX_TYPE_MISMATCH"
      level: "error"
      message: "ì ‘ë‘ì‚¬ì™€ íƒ€ì… ë¶ˆì¼ì¹˜: {field}ëŠ” {expected} íƒ€ì…ì´ì–´ì•¼ í•¨"

    - code: "UNSUPPORTED_STRUCTURE"
      level: "error"
      message: "ì§€ì›í•˜ì§€ ì•ŠëŠ” ìŠ¤í‚¤ë§ˆ êµ¬ì¡°: {structure}"

    - code: "INVALID_FIELD_NAME_POLICY"
      level: "error"
      message: "í•„ë“œëª… ì •ì±… ìœ„ë°˜: {field}"

    - code: "INVALID_YAML_KEY_POLICY"
      level: "error"
      message: "YAML í‚¤ ì •ì±… ìœ„ë°˜: {key}"

    - code: "OUTPUT_META_SOURCE_NOT_FOUND"
      level: "error"
      message: "outputMeta source ê²½ë¡œ í•´ì„ ì‹¤íŒ¨: {source}"

  warnings:
    - code: "MISSING_XUI_LABEL"
      level: "warn"
      message: "x-ui.label ëˆ„ë½: {field}"
      fix: "generate-from-key"

    - code: "MISSING_XUI_GROUP"
      level: "warn"
      message: "x-ui.group ëˆ„ë½: {field}"

    - code: "UNKNOWN_KEY"
      level: "warn"
      message: "ì•Œ ìˆ˜ ì—†ëŠ” í‚¤: {key}"

    - code: "UNKNOWN_MARKER"
      level: "warn"
      message: "ì•Œ ìˆ˜ ì—†ëŠ” ë§ˆì»¤: {marker}"

# ============================================================================
# SCHEMA LOGIC - ìŠ¤í‚¤ë§ˆ ì²˜ë¦¬ ë¡œì§ (ë„¤ì„ìŠ¤í˜ì´ìŠ¤)
# ============================================================================
schemaLogic:
  schemaStructurePatterns:
    - name: "Unwrap Root Wrapper Key"
      description: "ë£¨íŠ¸ ë˜í¼ í‚¤ë¥¼ ì œê±°í•˜ê³  ë‚´ë¶€ ìŠ¤í‚¤ë§ˆë¥¼ ëŒì–´ì˜¬ë¦¼"
      enabled: true
      priority: 1
      detect:
        - path: "$schema"
          exists: false
        - path: "type"
          exists: false
      transform:
        action: "unwrap-root-key"
        extractTitle: true
        preserveMetadata: ["description", "x-ui", "x-transport"]

  platformSkeleton:
    entityCollection:
      description: "Platform Standard Collection Map"
      type: "object"
      patternProperties:
        pattern: "^[0-9]+$"
        description: "Entity ID (numeric)"
        ref: "#/$defs/entity"
      additionalProperties: false
      minProperties: 0
    defaultBodyRoot: "Assign"
    alternativeBodyRoots:
      - "Argument"
      - "Assign"
    rootStructure:
      type: "object"
      additionalProperties: false

  sectionRules:
    - name: "Explicit SectionId"
      description: "x-ui.sectionIdê°€ ëª…ì‹œë˜ì–´ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš© (sectionRegistry.id ì°¸ì¡° í•„ìˆ˜)"
      condition:
        type: "has-explicit-sectionId"
      action:
        type: "use-explicit-sectionId"
        # âš ï¸ integrityRules.requireXuiSectionIdInRegistry=trueë¡œ ê²€ì¦
        # âš ï¸ x-ui.groupì€ deprecated - x-ui.sectionIdë¡œ ëŒ€ì²´
    - name: "Fallback"
      description: "ê¸°ë³¸ ì„¹ì…˜ (sectionRegistry SSOT)"
      condition:
        type: "always"
      action:
        type: "assign-section"
        sectionId: "SECTION_GENERAL"  # ğŸ”¥ sectionRegistry.id ì°¸ì¡°

  sectionOrder:
    - "SECTION_GENERAL"  # ğŸ”¥ sectionRegistry.id ì°¸ì¡°

  typeLabels: {}

  # Enum íŒì • ê·œì¹™
  # âš ï¸ êµ¬ì¡°í™”ëœ condition ì‚¬ìš© (ë¬¸ìì—´ í•˜ë“œì½”ë”© ê¸ˆì§€)
  #    markerRegistry.idë¥¼ ì§ì ‘ ì°¸ì¡°
  enumDetectionRules:
    - id: ENUM_EXPLICIT
      condition:
        type: "has-enum"
      description: "ëª…ì‹œì  enum ë°°ì—´ì´ ìˆìœ¼ë©´ enum"

    - id: ENUM_ONEOF_CONST
      condition:
        type: "has-oneOf-with-const"
      description: "oneOf ë‚´ë¶€ì— constê°€ ìˆìœ¼ë©´ enum"

    - id: ENUM_X_ENUM_BY_TYPE
      condition:
        type: "has-marker"
        markerId: "MARKER_ENUM_BY_TYPE"  # ğŸ”¥ markerRegistry.id ì°¸ì¡°
      description: "x-enum-by-type ë§ˆì»¤ê°€ ìˆìœ¼ë©´ ë™ì  enum"

  visibilityRules:
    - name: "No VisibleWhen"
      description: "visibleWhenì´ ì—†ìœ¼ë©´ í•­ìƒ í‘œì‹œ"
      condition:
        type: "no-visible-when"
      result: true
    - name: "TYPE Condition"
      description: "TYPE í•„ë“œ ì¡°ê±´ í™•ì¸"
      condition:
        type: "has-field-condition"
        field: "TYPE"
      evaluation:
        operator: "in"
        field: "TYPE"
    - name: "Other Field Conditions"
      description: "ë‹¤ë¥¸ í•„ë“œ ì¡°ê±´ í™•ì¸"
      condition:
        type: "has-other-conditions"
      evaluation:
        operator: "all-match"

  requiredCalculationRules:
    priority:
      - "base-required"
      - "conditional-required"
      - "visibility-check"
    baseRequired:
      description: "ìµœìƒìœ„ required ë°°ì—´ì— ìˆìœ¼ë©´ ëª¨ë“  TYPEì—ì„œ required"
      status: "required"
    conditionalRequired:
      description: "allOf ì¡°ê±´ì— ë§¤ì¹­ë˜ë©´ í•´ë‹¹ TYPEì—ì„œ required"
      status: "required"
    notVisible:
      description: "visibleWhen ì¡°ê±´ìœ¼ë¡œ ë³´ì´ì§€ ì•Šìœ¼ë©´ n/a"
      status: "n/a"
    default:
      description: "ê¸°ë³¸ê°’"
      status: "optional"

  # ê²€ì¦ ë ˆì´ì–´ ê²°ì • ê·œì¹™
  # âš ï¸ êµ¬ì¡°í™”ëœ condition ì‚¬ìš©
  validationLayerRules:
    STD:
      description: "Standard JSON Schema validation"
      triggers:
        - condition:
            type: "has-enum"
        - condition:
            type: "has-minItems"
        - condition:
            type: "has-maxItems"
        - condition:
            type: "has-type"
    APP:
      description: "Application-specific validation"
      triggers:
        - condition:
            type: "has-marker"
            markerId: "MARKER_ENUM_BY_TYPE"
        - condition:
            type: "has-marker"
            markerId: "MARKER_NODE_COUNT"
        - condition:
            type: "has-marker"
            markerId: "MARKER_VALUE_CONSTRAINT"

  descriptionBuildingRules:
    order:
      - label
      - enum-values
      - enum-by-type
      - value-constraints
      - node-count-by-type
      - hint
    templates:
      label: "<strong>{label}</strong>"
      enum-values:
        header: "<strong>Enum Values:</strong>"
        item: "<li><code>{value}</code> - {label}</li>"
        wrapper: "<ul>{items}</ul>"
      enum-by-type:
        header: "<strong>Enum Values by Type:</strong>"
        type-header: "<p><em>{type}:</em></p>"
        item: "<li><code>{value}</code> - {label}</li>"
        wrapper: "<ul>{items}</ul>"
      value-constraints:
        header: "<strong>Value Constraints:</strong>"
        item: "<li><em>{type}:</em> {constraint}</li>"
        wrapper: "<ul>{items}</ul>"
      node-count-by-type:
        header: "<strong>Node Count by Type:</strong>"
        item: "<li><em>{type}:</em> {count} nodes</li>"
        wrapper: "<ul>{items}</ul>"
      hint: '<p class="hint">{hint}</p>'
