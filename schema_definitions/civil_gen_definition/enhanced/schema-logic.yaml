# Enhanced Schema Logic Rules
# 스키마 처리 로직을 YAML로 정의하여 코드 변경 없이 규칙 수정 가능

# ============================================================================
# Schema Structure Patterns (스키마 구조 패턴)
# ============================================================================
schemaStructurePatterns:
  - name: "Unwrap Root Wrapper Key"
    description: "루트 래퍼 키를 제거하고 내부 스키마를 끌어올림 (예: {ELEM: {...}} → {...})"
    enabled: true
    priority: 1
    detect:
      - path: "$schema"
        exists: false
      - path: "type"
        exists: false
    transform:
      action: "unwrap-root-key"
      extractTitle: true
      preserveMetadata: ["description", "x-ui", "x-transport"]

# ============================================================================
# Platform Skeleton Definition (플랫폼 골격 정의)
# ============================================================================
platformSkeleton:
  # Entity Collection 구조
  entityCollection:
    description: "Platform Standard Collection Map"
    type: "object"
    patternProperties:
      pattern: "^[0-9]+$"  # ID 규칙: 숫자만 허용
      description: "Entity ID (numeric)"
      ref: "#/$defs/entity"
    additionalProperties: false  # 보안: 정의되지 않은 키 차단
    minProperties: 0
  
  # Body Root 기본값
  defaultBodyRoot: "Assign"
  
  # Body Root 대체값 (명시적으로 지정 가능)
  alternativeBodyRoots:
    - "Argument"
    - "Assign"
  
  # 조립된 스키마 최상위 구조
  rootStructure:
    type: "object"
    additionalProperties: false

# ============================================================================
# Section Determination Rules (섹션 결정 규칙)
# ============================================================================
# 플랫폼 공통 기본값 (Fallback)
# 각 스키마는 x-schema-rules로 자신만의 규칙을 정의해야 함
# ============================================================================
sectionRules:
  - name: "Explicit Group"
    description: "x-ui.group이 명시되어 있으면 그대로 사용"
    condition:
      type: "has-explicit-group"
    action:
      type: "use-explicit-group"
  
  - name: "Fallback"
    description: "기본 섹션"
    condition:
      type: "always"
    action:
      type: "assign-section"
      section: "General"

# ============================================================================
# Section Ordering (섹션 정렬 순서)
# ============================================================================
# 플랫폼 공통 기본값 (Fallback)
# 각 스키마는 x-schema-rules로 자신만의 순서를 정의해야 함
# ============================================================================
sectionOrder:
  - "General"

# ============================================================================
# Type Labels (타입 레이블 매핑)
# ============================================================================
# 플랫폼 공통 기본값 (빈 객체)
# 각 스키마는 x-schema-rules로 자신만의 레이블을 정의해야 함
# ============================================================================
typeLabels: {}

# ============================================================================
# Visibility Evaluation Rules (필드 표시 여부 평가 규칙)
# ============================================================================
visibilityRules:
  # visibleWhen 조건을 평가하는 규칙
  
  - name: "No VisibleWhen"
    description: "visibleWhen이 없으면 항상 표시"
    condition:
      type: "no-visible-when"
    result: true
  
  - name: "TYPE Condition"
    description: "TYPE 필드 조건 확인"
    condition:
      type: "has-field-condition"
      field: "TYPE"
    evaluation:
      # currentType이 allowedTypes에 포함되어야 함
      operator: "in"
      field: "TYPE"
  
  - name: "Other Field Conditions"
    description: "다른 필드 조건 확인"
    condition:
      type: "has-other-conditions"
    evaluation:
      # 모든 조건이 만족되어야 함
      operator: "all-match"

# ============================================================================
# Required Status Calculation Rules (Required 상태 계산 규칙)
# ============================================================================
requiredCalculationRules:
  priority:
    - "base-required"      # 최상위 required 배열
    - "conditional-required" # allOf 조건부 required
    - "visibility-check"   # visibleWhen 조건

  baseRequired:
    description: "최상위 required 배열에 있으면 모든 TYPE에서 required"
    status: "required"
  
  conditionalRequired:
    description: "allOf 조건에 매칭되면 해당 TYPE에서 required"
    status: "required"
  
  notVisible:
    description: "visibleWhen 조건으로 보이지 않으면 n/a"
    status: "n/a"
  
  default:
    description: "기본값"
    status: "optional"

# ============================================================================
# Validation Layer Rules (검증 레이어 결정 규칙)
# ============================================================================
validationLayerRules:
  STD:
    description: "Standard JSON Schema validation"
    triggers:
      - has-enum
      - has-minItems
      - has-maxItems
      - has-type
  
  APP:
    description: "Application-specific validation"
    triggers:
      - has-enumByType
      - has-nodeCountByType
      - has-valueConstraint
      - has-custom-x-field

# ============================================================================
# Field Description Building Rules (필드 설명 생성 규칙)
# ============================================================================
descriptionBuildingRules:
  order:
    - label
    - enum-values
    - enum-by-type
    - value-constraints
    - node-count-by-type
    - hint
  
  templates:
    label: "<strong>{label}</strong>"
    enum-values:
      header: "<strong>Enum Values:</strong>"
      item: "<li><code>{value}</code> - {label}</li>"
      wrapper: "<ul>{items}</ul>"
    
    enum-by-type:
      header: "<strong>Enum Values by Type:</strong>"
      type-header: "<p><em>{type}:</em></p>"
      item: "<li><code>{value}</code> - {label}</li>"
      wrapper: "<ul>{items}</ul>"
    
    value-constraints:
      header: "<strong>Value Constraints:</strong>"
      item: "<li><em>{type}:</em> {constraint}</li>"
      wrapper: "<ul>{items}</ul>"
    
    node-count-by-type:
      header: "<strong>Node Count by Type:</strong>"
      item: "<li><em>{type}:</em> {count} nodes</li>"
      wrapper: "<ul>{items}</ul>"
    
    hint: '<p class="hint">{hint}</p>'

